Input,Is Correct,Expected If Condition,Predicted If Condition,Prediction Score
"def _delete_initial(self, resource_group_name: str, network_manager_name: str, configuration_name: str, *, force: Optional[bool]=None, **kwargs: Any) -> Iterator[bytes]:    error_map: MutableMapping[int, Type[HttpResponseError]] = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError, 304: ResourceNotModifiedError}    error_map.update(kwargs.pop('error_map', {}) or {})    _headers = kwargs.pop('headers', {}) or {}    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})    api_version: str = kwargs.pop('api_version', _params.pop('api-version', self._api_version or '2024-03-01'))    cls: ClsType[Iterator[bytes]] = kwargs.pop('cls', None)    _request = build_security_user_configurations_delete_request(resource_group_name=resource_group_name, network_manager_name=network_manager_name, configuration_name=configuration_name, subscription_id=self._config.subscription_id, force=force, api_version=api_version, headers=_headers, params=_params)    _request.url = self._client.format_url(_request.url)    _decompress = kwargs.pop('decompress', True)    _stream = True    pipeline_response: PipelineResponse = self._client._pipeline.run(_request, stream=_stream, **kwargs)    response = pipeline_response.http_response    <extra_id_0>        return cls(pipeline_response, deserialized, response_headers)    return deserialized@api_version_validation(method_valid_on=['2024-03-01'])@distributed_trace",False,"if response.status_code not in [200, 202, 204]:        try:            response.read()        except (StreamConsumedError, StreamClosedError):            pass        map_error(status_code=response.status_code, response=response, error_map=error_map)        raise HttpResponseError(response=response, error_format=ARMErrorFormat)    response_headers = {}    if response.status_code == 202:        response_headers['Location'] = self._deserialize('str', response.headers.get('Location'))    deserialized = response.stream_download(self._client._pipeline, decompress=_decompress)    if cls:","def _delete_initial(self, resource_group_name: str, network_manager_name: str, configuration_name: str, *, force: Optional[bool]=None, **kwargs: Any): -> Iterator[bytes]:    error_map: MutableMapping[int, Type[HttpResponseError]] = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError, 304: ResourceNotModifiedError}    error_map.update(kwargs.pop('error_map', {}) or {})    _headers = kwargs.pop",99.47
"def begin_delete(self, resource_group_name: str, network_manager_name: str, configuration_name: str, *, force: Optional[bool]=None, **kwargs: Any) -> LROPoller[None]:        _headers = kwargs.pop('headers', {}) or {}    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})    api_version: str = kwargs.pop('api_version', _params.pop('api-version', self._api_version or '2024-03-01'))    cls: ClsType[None] = kwargs.pop('cls', None)    polling: Union[bool, PollingMethod] = kwargs.pop('polling', True)    lro_delay = kwargs.pop('polling_interval', self._config.polling_interval)    cont_token: Optional[str] = kwargs.pop('continuation_token', None)    <extra_id_0> x, headers=_headers, params=_params, **kwargs)        raw_result.http_response.read()    kwargs.pop('error_map', None)",False,"if cont_token is None:        raw_result = self._delete_initial(resource_group_name=resource_group_name, network_manager_name=network_manager_name, configuration_name=configuration_name, force=force, api_version=api_version, cls=lambda x, y, z:","def begin_delete(self, resource_group_name: str, network_manager_name: str, configuration_name: str, *, force: Optional[bool]=None, **kwargs: Any) -> LROPoller[None]:        _headers = kwargs.pop('headers', {}) or {}    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})    api_version: str = kwargs.pop('api-version', self._api_version or '2024-03-01'))    cls",99.42
"def get_long_running_output(pipeline_response):        <extra_id_0>        return LROPoller[None].from_continuation_token(polling_method=polling_method, continuation_token=cont_token, client=self._client, deserialization_callback=get_long_running_output)    return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)",False,"if cls:            return cls(pipeline_response, None, {})    if polling is True:        polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, lro_options={'final-state-via': 'location'}, **kwargs))    elif polling is False:        polling_method = cast(PollingMethod, NoPolling())    else:        polling_method = polling    if cont_token:","def get_long_running_output(pipeline_response):
        if pipeline_response.status_code == 200:
            return LROPoller[None].from_continuation_token(polling_method=polling_method, continuation_token=cont_token, client=self._client, deserialization_callback=get_long_running_output)    return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)",94.59
"def build_user_rule_collections_create_or_update_request(resource_group_name: str, network_manager_name: str, configuration_name: str, rule_collection_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:    _headers = case_insensitive_dict(kwargs.pop('headers', {}) or {})    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})    api_version: str = kwargs.pop('api_version', _params.pop('api-version', '2021-02-01-preview'))    content_type: Optional[str] = kwargs.pop('content_type', _headers.pop('Content-Type', None))    accept = _headers.pop('Accept', 'application/json')    _url = kwargs.pop('template_url', '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkManagers/{networkManagerName}/securityUserConfigurations/{configurationName}/ruleCollections/{ruleCollectionName}')    path_format_arguments = {'subscriptionId': _SERIALIZER.url('subscription_id', subscription_id, 'str'), 'resourceGroupName': _SERIALIZER.url('resource_group_name', resource_group_name, 'str'), 'networkManagerName': _SERIALIZER.url('network_manager_name', network_manager_name, 'str'), 'configurationName': _SERIALIZER.url('configuration_name', configuration_name, 'str'), 'ruleCollectionName': _SERIALIZER.url('rule_collection_name', rule_collection_name, 'str')}    _url: str = _url.format(**path_format_arguments)    _params['api-version'] = _SERIALIZER.query('api_version', api_version, 'str')    <extra_id_0>        _headers['Content-Type'] = _SERIALIZER.header('content_type', content_type, 'str')    _headers['Accept'] = _SERIALIZER.header('accept', accept, 'str')    return HttpRequest(method='PUT', url=_url, params=_params, headers=_headers, **kwargs)",False,if content_type is not None:,"def build_user_rule_collections_create_or_update_request(resource_group_name: str, network_manager_name: str, configuration_name: str, rule_collection_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:    _headers = case_insensitive_dict(kwargs.pop('headers', {}) or {})    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})    content_type: Optional[str] = kwargs.pop('content_",99.57
"def build_user_rule_collections_list_request(resource_group_name: str, network_manager_name: str, configuration_name: str, subscription_id: str, *, top: Optional[int]=None, skip_token: Optional[str]=None, **kwargs: Any) -> HttpRequest:    _headers = case_insensitive_dict(kwargs.pop('headers', {}) or {})    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})    api_version: str = kwargs.pop('api_version', _params.pop('api-version', '2021-02-01-preview'))    accept = _headers.pop('Accept', 'application/json')    _url = kwargs.pop('template_url', '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkManagers/{networkManagerName}/securityUserConfigurations/{configurationName}/ruleCollections')    path_format_arguments = {'subscriptionId': _SERIALIZER.url('subscription_id', subscription_id, 'str'), 'resourceGroupName': _SERIALIZER.url('resource_group_name', resource_group_name, 'str'), 'networkManagerName': _SERIALIZER.url('network_manager_name', network_manager_name, 'str'), 'configurationName': _SERIALIZER.url('configuration_name', configuration_name, 'str')}    _url: str = _url.format(**path_format_arguments)    _params['api-version'] = _SERIALIZER.query('api_version', api_version, 'str')    <extra_id_0>        _params['$skipToken'] = _SERIALIZER.query('skip_token', skip_token, 'str')    _headers['Accept'] = _SERIALIZER.header('accept', accept, 'str')    return HttpRequest(method='GET', url=_url, params=_params, headers=_headers, **kwargs)",False,"if top is not None:        _params['$top'] = _SERIALIZER.query('top', top, 'int', maximum=20, minimum=1)    if skip_token is not None:","def build_user_rule_collections_list_request(resource_group_name: str, network_manager_name: str, configuration_name: str, subscription_id: str, *, top: Optional[int]=None, skip_token: Optional[str]=None, **kwargs: Any) -> HttpRequest:    _headers = case_insensitive_dict(kwargs.pop('headers', {}) or {})    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})    api_version: str",99.51
"def __init__(self, *args, **kwargs):    input_args = list(args)    self._client = input_args.pop(0) if input_args else kwargs.pop('client')    self._config = input_args.pop(0) if input_args else kwargs.pop('config')    self._serialize = input_args.pop(0) if input_args else kwargs.pop('serializer')    self._deserialize = input_args.pop(0) if input_args else kwargs.pop('deserializer')    self._api_version = input_args.pop(0) if input_args else kwargs.pop('api_version')@distributed_trace",False,,"def __init__ (self, *args, **kwargs):    input_args = list(args)    self._client = input_args.pop(0) if input_args else kwargs.pop('client')    self._config = input_args.pop(0) if input_args else kwargs.pop('config')    self._serialize = input_args.pop(0) if input_args else kwargs.pop('serializer')    self._deserialize = input_args.pop(0) if input_args else kwargs.pop('serializer')   ",99.53
"def create_or_update(self, resource_group_name: str, network_manager_name: str, configuration_name: str, rule_collection_name: str, user_rule_collection: Union[_models.RuleCollection, IO[bytes]], **kwargs: Any) -> _models.RuleCollection:        error_map: MutableMapping[int, Type[HttpResponseError]] = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError, 304: ResourceNotModifiedError}    error_map.update(kwargs.pop('error_map', {}) or {})    _headers = case_insensitive_dict(kwargs.pop('headers', {}) or {})    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})    api_version: str = kwargs.pop('api_version', _params.pop('api-version', self._api_version or '2021-02-01-preview'))    content_type: Optional[str] = kwargs.pop('content_type', _headers.pop('Content-Type', None))    cls: ClsType[_models.RuleCollection] = kwargs.pop('cls', None)    content_type = content_type or 'application/json'    _json = None    _content = None    <extra_id_0>        return cls(pipeline_response, deserialized, {})    return deserialized@distributed_trace",False,"if isinstance(user_rule_collection, (IOBase, bytes)):        _content = user_rule_collection    else:        _json = self._serialize.body(user_rule_collection, 'RuleCollection')    _request = build_user_rule_collections_create_or_update_request(resource_group_name=resource_group_name, network_manager_name=network_manager_name, configuration_name=configuration_name, rule_collection_name=rule_collection_name, subscription_id=self._config.subscription_id, api_version=api_version, content_type=content_type, json=_json, content=_content, headers=_headers, params=_params)    _request.url = self._client.format_url(_request.url)    _stream = False    pipeline_response: PipelineResponse = self._client._pipeline.run(_request, stream=_stream, **kwargs)    response = pipeline_response.http_response    if response.status_code not in [200, 201]:        map_error(status_code=response.status_code, response=response, error_map=error_map)        raise HttpResponseError(response=response, error_format=ARMErrorFormat)    deserialized = self._deserialize('RuleCollection', pipeline_response.http_response)    if cls:","def create_or_update(self, resource_group_name: str, network_manager_name: str, configuration_name: str, rule_collection_name: str, user_rule_collection: Union[_models.RuleCollection, IO[bytes]], **kwargs: Any) -> _models.RuleCollection:        error_map: MutableMapping[int, Type[HttpResponseError]] = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError, 304: ResourceNotModifiedError}    error_map.update(kwargs",99.85
"def delete(self, resource_group_name: str, network_manager_name: str, configuration_name: str, rule_collection_name: str, **kwargs: Any) -> None:        error_map: MutableMapping[int, Type[HttpResponseError]] = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError, 304: ResourceNotModifiedError}    error_map.update(kwargs.pop('error_map', {}) or {})    _headers = kwargs.pop('headers', {}) or {}    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})    api_version: str = kwargs.pop('api_version', _params.pop('api-version', self._api_version or '2021-02-01-preview'))    cls: ClsType[None] = kwargs.pop('cls', None)    _request = build_user_rule_collections_delete_request(resource_group_name=resource_group_name, network_manager_name=network_manager_name, configuration_name=configuration_name, rule_collection_name=rule_collection_name, subscription_id=self._config.subscription_id, api_version=api_version, headers=_headers, params=_params)    _request.url = self._client.format_url(_request.url)    _stream = False    pipeline_response: PipelineResponse = self._client._pipeline.run(_request, stream=_stream, **kwargs)    response = pipeline_response.http_response    <extra_id_0>        return cls(pipeline_response, None, {})@distributed_trace",False,"if response.status_code not in [200, 204]:        map_error(status_code=response.status_code, response=response, error_map=error_map)        raise HttpResponseError(response=response, error_format=ARMErrorFormat)    if cls:","def delete(self, resource_group_name: str, network_manager_name: str, configuration_name: str, rule_collection_name: str, **kwargs: Any) -> None:        error_map: MutableMapping[int, Type[HttpResponseError]] = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError, 304: ResourceNotModifiedError}    error_map.update(kwargs.pop('error_map', {}) or {})    _headers = kwargs.pop('headers', {}) or {}   ",99.58
"def get(self, resource_group_name: str, network_manager_name: str, configuration_name: str, rule_collection_name: str, **kwargs: Any) -> _models.RuleCollection:        error_map: MutableMapping[int, Type[HttpResponseError]] = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError, 304: ResourceNotModifiedError}    error_map.update(kwargs.pop('error_map', {}) or {})    _headers = kwargs.pop('headers', {}) or {}    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})    api_version: str = kwargs.pop('api_version', _params.pop('api-version', self._api_version or '2021-02-01-preview'))    cls: ClsType[_models.RuleCollection] = kwargs.pop('cls', None)    _request = build_user_rule_collections_get_request(resource_group_name=resource_group_name, network_manager_name=network_manager_name, configuration_name=configuration_name, rule_collection_name=rule_collection_name, subscription_id=self._config.subscription_id, api_version=api_version, headers=_headers, params=_params)    _request.url = self._client.format_url(_request.url)    _stream = False    pipeline_response: PipelineResponse = self._client._pipeline.run(_request, stream=_stream, **kwargs)    response = pipeline_response.http_response    <extra_id_0>        return cls(pipeline_response, deserialized, {})    return deserialized@distributed_trace",False,"if response.status_code not in [200]:        map_error(status_code=response.status_code, response=response, error_map=error_map)        raise HttpResponseError(response=response, error_format=ARMErrorFormat)    deserialized = self._deserialize('RuleCollection', pipeline_response.http_response)    if cls:","def get(self, resource_group_name: str, network_manager_name: str, configuration_name: str, rule_collection_name: str, **kwargs: Any) -> _models.RuleCollection:        error_map: MutableMapping[int, Type[HttpResponseError]] = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError, 304: ResourceNotModifiedError}    error_map.update(kwargs.pop('error_map', {}) or {})    _headers = kwargs.pop('headers', {}",99.67
"def prepare_request(next_link=None):        <extra_id_0> [urllib.parse.quote(v) for v in value] for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()})            _next_request_params['api-version'] = self._api_version            _request = HttpRequest('GET', urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params)            _request.url = self._client.format_url(_request.url)            _request.method = 'GET'        return _request",False,"if not next_link:            _request = build_user_rule_collections_list_request(resource_group_name=resource_group_name, network_manager_name=network_manager_name, configuration_name=configuration_name, subscription_id=self._config.subscription_id, top=top, skip_token=skip_token, api_version=api_version, headers=_headers, params=_params)            _request.url = self._client.format_url(_request.url)        else:            _parsed_next_link = urllib.parse.urlparse(next_link)            _next_request_params = case_insensitive_dict({key:","def prepare_request(next_link=None): # pylint: disable=protected-access, no-access, no-access, no-access, no-access, no-access, no-access, no-access, no-access, no-access, no-access, no-access, no-access, no-access, no-access, no-access, no-access, no-access, no-access, no-access, no-access, no-access, no-access, no-access, no-access, no-access",92.82
"def extract_data(pipeline_response):        deserialized = self._deserialize('RuleCollectionListResult', pipeline_response)        list_of_elem = deserialized.value        <extra_id_0>            list_of_elem = cls(list_of_elem)        return (deserialized.next_link or None, iter(list_of_elem))",False,if cls:,"def extract_data(self, pipeline_response):        deserialized = self._deserialize('RuleCollectionListResult', pipeline_response)        list_of_elem = deserialized.value
        if isinstance(list_of_elem, RuleCollectionListResult):
            list_of_elem = cls(list_of_elem)        return (deserialized.next_link or None, iter(list_of_elem))",95.28
"def get_next(next_link=None):        _request = prepare_request(next_link)        _stream = False        pipeline_response: PipelineResponse = self._client._pipeline.run(_request, stream=_stream, **kwargs)        response = pipeline_response.http_response        <extra_id_0>            map_error(status_code=response.status_code, response=response, error_map=error_map)            raise HttpResponseError(response=response, error_format=ARMErrorFormat)        return pipeline_response    return ItemPaged(get_next, extract_data)",False,if response.status_code not in [200]:,"def get_next(self, next_link=None):        _request = prepare_request(next_link)        _stream = False        pipeline_response: PipelineResponse = self._client._pipeline.run(_request, stream=_stream, **kwargs)        response = pipeline_response.http_response
        if response.status_code == 200:
            response = pipeline_response.http_response
        if response.status_code == 200:
            response = response.http_response
        if response.status_code == 200:",90.35
"def build_user_rules_create_or_update_request(resource_group_name: str, network_manager_name: str, configuration_name: str, rule_collection_name: str, rule_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:    _headers = case_insensitive_dict(kwargs.pop('headers', {}) or {})    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})    api_version: str = kwargs.pop('api_version', _params.pop('api-version', '2021-02-01-preview'))    content_type: Optional[str] = kwargs.pop('content_type', _headers.pop('Content-Type', None))    accept = _headers.pop('Accept', 'application/json')    _url = kwargs.pop('template_url', '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkManagers/{networkManagerName}/securityUserConfigurations/{configurationName}/ruleCollections/{ruleCollectionName}/rules/{ruleName}')    path_format_arguments = {'subscriptionId': _SERIALIZER.url('subscription_id', subscription_id, 'str'), 'resourceGroupName': _SERIALIZER.url('resource_group_name', resource_group_name, 'str'), 'networkManagerName': _SERIALIZER.url('network_manager_name', network_manager_name, 'str'), 'configurationName': _SERIALIZER.url('configuration_name', configuration_name, 'str'), 'ruleCollectionName': _SERIALIZER.url('rule_collection_name', rule_collection_name, 'str'), 'ruleName': _SERIALIZER.url('rule_name', rule_name, 'str')}    _url: str = _url.format(**path_format_arguments)    _params['api-version'] = _SERIALIZER.query('api_version', api_version, 'str')    <extra_id_0>        _headers['Content-Type'] = _SERIALIZER.header('content_type', content_type, 'str')    _headers['Accept'] = _SERIALIZER.header('accept', accept, 'str')    return HttpRequest(method='PUT', url=_url, params=_params, headers=_headers, **kwargs)",False,if content_type is not None:,"def build_user_rules_create_or_update_request(resource_group_name: str, network_manager_name: str, configuration_name: str, rule_collection_name: str, rule_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:    _headers = case_insensitive_dict(kwargs.pop('headers', {}) or {})    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})    content_type: Optional[str] = kwargs.",99.75
"def build_user_rules_list_request(resource_group_name: str, network_manager_name: str, configuration_name: str, rule_collection_name: str, subscription_id: str, *, top: Optional[int]=None, skip_token: Optional[str]=None, **kwargs: Any) -> HttpRequest:    _headers = case_insensitive_dict(kwargs.pop('headers', {}) or {})    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})    api_version: str = kwargs.pop('api_version', _params.pop('api-version', '2021-02-01-preview'))    accept = _headers.pop('Accept', 'application/json')    _url = kwargs.pop('template_url', '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkManagers/{networkManagerName}/securityUserConfigurations/{configurationName}/ruleCollections/{ruleCollectionName}/rules')    path_format_arguments = {'subscriptionId': _SERIALIZER.url('subscription_id', subscription_id, 'str'), 'resourceGroupName': _SERIALIZER.url('resource_group_name', resource_group_name, 'str'), 'networkManagerName': _SERIALIZER.url('network_manager_name', network_manager_name, 'str'), 'configurationName': _SERIALIZER.url('configuration_name', configuration_name, 'str'), 'ruleCollectionName': _SERIALIZER.url('rule_collection_name', rule_collection_name, 'str')}    _url: str = _url.format(**path_format_arguments)    _params['api-version'] = _SERIALIZER.query('api_version', api_version, 'str')    <extra_id_0>        _params['$skipToken'] = _SERIALIZER.query('skip_token', skip_token, 'str')    _headers['Accept'] = _SERIALIZER.header('accept', accept, 'str')    return HttpRequest(method='GET', url=_url, params=_params, headers=_headers, **kwargs)",False,"if top is not None:        _params['$top'] = _SERIALIZER.query('top', top, 'int', maximum=20, minimum=1)    if skip_token is not None:","def build_user_rules_list_request(resource_group_name: str, network_manager_name: str, configuration_name: str, rule_collection_name: str, subscription_id: str, *, top: Optional[int]=None, skip_token: Optional[str]=None, **kwargs: Any) -> HttpRequest:    _headers = case_insensitive_dict(kwargs.pop('headers', {}) or {})    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})",99.71
"def __init__(self, *args, **kwargs):    input_args = list(args)    self._client = input_args.pop(0) if input_args else kwargs.pop('client')    self._config = input_args.pop(0) if input_args else kwargs.pop('config')    self._serialize = input_args.pop(0) if input_args else kwargs.pop('serializer')    self._deserialize = input_args.pop(0) if input_args else kwargs.pop('deserializer')    self._api_version = input_args.pop(0) if input_args else kwargs.pop('api_version')@distributed_trace",False,,"def __init__ (self, *args, **kwargs):    input_args = list(args)    self._client = input_args.pop(0) if input_args else kwargs.pop('client')    self._config = input_args.pop(0) if input_args else kwargs.pop('config')    self._serialize = input_args.pop(0) if input_args else kwargs.pop('serializer')    self._deserialize = input_args.pop(0) if input_args else kwargs.pop('serializer')   ",99.53
"def create_or_update(self, resource_group_name: str, network_manager_name: str, configuration_name: str, rule_collection_name: str, rule_name: str, user_rule: Union[_models.BaseUserRule, IO[bytes]], **kwargs: Any) -> _models.BaseUserRule:        error_map: MutableMapping[int, Type[HttpResponseError]] = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError, 304: ResourceNotModifiedError}    error_map.update(kwargs.pop('error_map', {}) or {})    _headers = case_insensitive_dict(kwargs.pop('headers', {}) or {})    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})    api_version: str = kwargs.pop('api_version', _params.pop('api-version', self._api_version or '2021-02-01-preview'))    content_type: Optional[str] = kwargs.pop('content_type', _headers.pop('Content-Type', None))    cls: ClsType[_models.BaseUserRule] = kwargs.pop('cls', None)    content_type = content_type or 'application/json'    _json = None    _content = None    <extra_id_0>        return cls(pipeline_response, deserialized, {})    return deserialized@distributed_trace",False,"if isinstance(user_rule, (IOBase, bytes)):        _content = user_rule    else:        _json = self._serialize.body(user_rule, 'BaseUserRule')    _request = build_user_rules_create_or_update_request(resource_group_name=resource_group_name, network_manager_name=network_manager_name, configuration_name=configuration_name, rule_collection_name=rule_collection_name, rule_name=rule_name, subscription_id=self._config.subscription_id, api_version=api_version, content_type=content_type, json=_json, content=_content, headers=_headers, params=_params)    _request.url = self._client.format_url(_request.url)    _stream = False    pipeline_response: PipelineResponse = self._client._pipeline.run(_request, stream=_stream, **kwargs)    response = pipeline_response.http_response    if response.status_code not in [200, 201]:        map_error(status_code=response.status_code, response=response, error_map=error_map)        raise HttpResponseError(response=response, error_format=ARMErrorFormat)    deserialized = self._deserialize('BaseUserRule', pipeline_response.http_response)    if cls:","def create_or_update(self, resource_group_name: str, network_manager_name: str, configuration_name: str, rule_collection_name: str, rule_name: str, user_rule: Union[_models.BaseUserRule, IO[bytes]], **kwargs: Any) -> _models.BaseUserRule:        error_map: MutableMapping[int, Type[HttpResponseError]] = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError, 304: ResourceNotModifiedError}    error",99.86
"def delete(self, resource_group_name: str, network_manager_name: str, configuration_name: str, rule_collection_name: str, rule_name: str, **kwargs: Any) -> None:        error_map: MutableMapping[int, Type[HttpResponseError]] = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError, 304: ResourceNotModifiedError}    error_map.update(kwargs.pop('error_map', {}) or {})    _headers = kwargs.pop('headers', {}) or {}    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})    api_version: str = kwargs.pop('api_version', _params.pop('api-version', self._api_version or '2021-02-01-preview'))    cls: ClsType[None] = kwargs.pop('cls', None)    _request = build_user_rules_delete_request(resource_group_name=resource_group_name, network_manager_name=network_manager_name, configuration_name=configuration_name, rule_collection_name=rule_collection_name, rule_name=rule_name, subscription_id=self._config.subscription_id, api_version=api_version, headers=_headers, params=_params)    _request.url = self._client.format_url(_request.url)    _stream = False    pipeline_response: PipelineResponse = self._client._pipeline.run(_request, stream=_stream, **kwargs)    response = pipeline_response.http_response    <extra_id_0>        return cls(pipeline_response, None, {})@distributed_trace",False,"if response.status_code not in [200, 204]:        map_error(status_code=response.status_code, response=response, error_map=error_map)        raise HttpResponseError(response=response, error_format=ARMErrorFormat)    if cls:","def delete(self, resource_group_name: str, network_manager_name: str, configuration_name: str, rule_collection_name: str, rule_name: str, **kwargs: Any) -> None:        error_map: MutableMapping[int, Type[HttpResponseError]] = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError, 304: ResourceNotModifiedError}    error_map.update(kwargs.pop('error_map', {}) or {})    _headers = kwargs.pop('headers",99.65
"def get(self, resource_group_name: str, network_manager_name: str, configuration_name: str, rule_collection_name: str, rule_name: str, **kwargs: Any) -> _models.BaseUserRule:        error_map: MutableMapping[int, Type[HttpResponseError]] = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError, 304: ResourceNotModifiedError}    error_map.update(kwargs.pop('error_map', {}) or {})    _headers = kwargs.pop('headers', {}) or {}    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})    api_version: str = kwargs.pop('api_version', _params.pop('api-version', self._api_version or '2021-02-01-preview'))    cls: ClsType[_models.BaseUserRule] = kwargs.pop('cls', None)    _request = build_user_rules_get_request(resource_group_name=resource_group_name, network_manager_name=network_manager_name, configuration_name=configuration_name, rule_collection_name=rule_collection_name, rule_name=rule_name, subscription_id=self._config.subscription_id, api_version=api_version, headers=_headers, params=_params)    _request.url = self._client.format_url(_request.url)    _stream = False    pipeline_response: PipelineResponse = self._client._pipeline.run(_request, stream=_stream, **kwargs)    response = pipeline_response.http_response    <extra_id_0>        return cls(pipeline_response, deserialized, {})    return deserialized@distributed_trace",False,"if response.status_code not in [200]:        map_error(status_code=response.status_code, response=response, error_map=error_map)        raise HttpResponseError(response=response, error_format=ARMErrorFormat)    deserialized = self._deserialize('BaseUserRule', pipeline_response.http_response)    if cls:","def get(self, resource_group_name: str, network_manager_name: str, configuration_name: str, rule_collection_name: str, rule_name: str, **kwargs: Any) -> _models.BaseUserRule:        error_map: MutableMapping[int, Type[HttpResponseError]] = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError, 304: ResourceNotModifiedError}    error_map.update(kwargs.pop('error_map', {}) or {})

 = kwargs",98.37
"def prepare_request(next_link=None):        <extra_id_0> [urllib.parse.quote(v) for v in value] for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()})            _next_request_params['api-version'] = self._api_version            _request = HttpRequest('GET', urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params)            _request.url = self._client.format_url(_request.url)            _request.method = 'GET'        return _request",False,"if not next_link:            _request = build_user_rules_list_request(resource_group_name=resource_group_name, network_manager_name=network_manager_name, configuration_name=configuration_name, rule_collection_name=rule_collection_name, subscription_id=self._config.subscription_id, top=top, skip_token=skip_token, api_version=api_version, headers=_headers, params=_params)            _request.url = self._client.format_url(_request.url)        else:            _parsed_next_link = urllib.parse.urlparse(next_link)            _next_request_params = case_insensitive_dict({key:","def prepare_request(next_link=None): # pylint: disable=protected-access, no-access, no-access, no-access, no-access, no-access, no-access, no-access, no-access, no-access, no-access, no-access, no-access, no-access, no-access, no-access, no-access, no-access, no-access, no-access, no-access, no-access, no-access, no-access, no-access, no-access",92.82
"def extract_data(pipeline_response):        deserialized = self._deserialize('UserRuleListResult', pipeline_response)        list_of_elem = deserialized.value        <extra_id_0>            list_of_elem = cls(list_of_elem)        return (deserialized.next_link or None, iter(list_of_elem))",False,if cls:,"def extract_data(self, pipeline_response):        deserialized = self._deserialize('UserRuleListResult', pipeline_response)        list_of_elem = deserialized.value
        if isinstance(list_of_elem, list):
            list_of_elem = cls(list_of_elem)        return (deserialized.next_link or None, iter(list_of_elem))",95.87
"def get_next(next_link=None):        _request = prepare_request(next_link)        _stream = False        pipeline_response: PipelineResponse = self._client._pipeline.run(_request, stream=_stream, **kwargs)        response = pipeline_response.http_response        <extra_id_0>            map_error(status_code=response.status_code, response=response, error_map=error_map)            raise HttpResponseError(response=response, error_format=ARMErrorFormat)        return pipeline_response    return ItemPaged(get_next, extract_data)",False,if response.status_code not in [200]:,"def get_next(self, next_link=None):        _request = prepare_request(next_link)        _stream = False        pipeline_response: PipelineResponse = self._client._pipeline.run(_request, stream=_stream, **kwargs)        response = pipeline_response.http_response
        if response.status_code == 200:
            response = pipeline_response.http_response
        if response.status_code == 200:
            response = response.http_response
        if response.status_code == 200:",90.35
"def __init__(self, *args, **kwargs):    input_args = list(args)    self._client = input_args.pop(0) if input_args else kwargs.pop('client')    self._config = input_args.pop(0) if input_args else kwargs.pop('config')    self._serialize = input_args.pop(0) if input_args else kwargs.pop('serializer')    self._deserialize = input_args.pop(0) if input_args else kwargs.pop('deserializer')    self._api_version = input_args.pop(0) if input_args else kwargs.pop('api_version')@distributed_trace",False,,"def __init__ (self, *args, **kwargs):    input_args = list(args)    self._client = input_args.pop(0) if input_args else kwargs.pop('client')    self._config = input_args.pop(0) if input_args else kwargs.pop('config')    self._serialize = input_args.pop(0) if input_args else kwargs.pop('serializer')    self._deserialize = input_args.pop(0) if input_args else kwargs.pop('serializer')   ",99.53
"def get(self, location: str, **kwargs: Any) -> _models.ApplicationGatewayWafDynamicManifestResult:        error_map: MutableMapping[int, Type[HttpResponseError]] = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError, 304: ResourceNotModifiedError}    error_map.update(kwargs.pop('error_map', {}) or {})    _headers = kwargs.pop('headers', {}) or {}    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})    api_version: str = kwargs.pop('api_version', _params.pop('api-version', self._api_version or '2024-03-01'))    cls: ClsType[_models.ApplicationGatewayWafDynamicManifestResult] = kwargs.pop('cls', None)    _request = build_application_gateway_waf_dynamic_manifests_default_get_request(location=location, subscription_id=self._config.subscription_id, api_version=api_version, headers=_headers, params=_params)    _request.url = self._client.format_url(_request.url)    _stream = False    pipeline_response: PipelineResponse = self._client._pipeline.run(_request, stream=_stream, **kwargs)    response = pipeline_response.http_response    <extra_id_0>        return cls(pipeline_response, deserialized, {})    return deserialized",False,"if response.status_code not in [200]:        map_error(status_code=response.status_code, response=response, error_map=error_map)        raise HttpResponseError(response=response, error_format=ARMErrorFormat)    deserialized = self._deserialize('ApplicationGatewayWafDynamicManifestResult', pipeline_response.http_response)    if cls:","def get(self, location: str, **kwargs: Any): -> _models.ApplicationGatewayWafDynamicManifestResult:        error_map: MutableMapping[int, Type[HttpResponseError]] = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError, 304: ResourceNotModifiedError}    error_map.update(kwargs.pop('error_map', {}) or {})    _headers = kwargs.pop('headers', {}) or {}    _params = case_insensitive_dict(kwargs.pop('params', {})",99.47
"def __init__(self, *args, **kwargs):    input_args = list(args)    self._client = input_args.pop(0) if input_args else kwargs.pop('client')    self._config = input_args.pop(0) if input_args else kwargs.pop('config')    self._serialize = input_args.pop(0) if input_args else kwargs.pop('serializer')    self._deserialize = input_args.pop(0) if input_args else kwargs.pop('deserializer')    self._api_version = input_args.pop(0) if input_args else kwargs.pop('api_version')@distributed_trace",False,,"def __init__ (self, *args, **kwargs):    input_args = list(args)    self._client = input_args.pop(0) if input_args else kwargs.pop('client')    self._config = input_args.pop(0) if input_args else kwargs.pop('config')    self._serialize = input_args.pop(0) if input_args else kwargs.pop('serializer')    self._deserialize = input_args.pop(0) if input_args else kwargs.pop('serializer')   ",99.53
"def prepare_request(next_link=None):        <extra_id_0>            _request = HttpRequest('GET', next_link)            _request.url = self._client.format_url(_request.url)            _request.method = 'GET'        return _request",False,"if not next_link:            _request = build_application_gateway_waf_dynamic_manifests_get_request(location=location, subscription_id=self._config.subscription_id, api_version=api_version, headers=_headers, params=_params)            _request.url = self._client.format_url(_request.url)        else:","def prepare_request(self, next_link=None):if next_link is not None: _request = self._client.format_url(_request.url)            _request.method = 'GET'        return _request",92.65
"def extract_data(pipeline_response):        deserialized = self._deserialize('ApplicationGatewayWafDynamicManifestResultList', pipeline_response)        list_of_elem = deserialized.value        <extra_id_0>            list_of_elem = cls(list_of_elem)        return (deserialized.next_link or None, iter(list_of_elem))",False,if cls:,"def extract_data(self, pipeline_response):        deserialized = self._deserialize('ApplicationGatewayWafDynamicManifestResultList', pipeline_response)        list_of_elem = deserialized.value
        if isinstance(list_of_elem, MutableMapping):            list_of_elem = cls(list_of_elem)        return (deserialized.next_link or None, iter(list_of_elem))",96.16
"def get_next(next_link=None):        _request = prepare_request(next_link)        _stream = False        pipeline_response: PipelineResponse = self._client._pipeline.run(_request, stream=_stream, **kwargs)        response = pipeline_response.http_response        <extra_id_0>            map_error(status_code=response.status_code, response=response, error_map=error_map)            raise HttpResponseError(response=response, error_format=ARMErrorFormat)        return pipeline_response    return ItemPaged(get_next, extract_data)",False,if response.status_code not in [200]:,"def get_next(self, next_link=None):        _request = prepare_request(next_link)        _stream = False        pipeline_response: PipelineResponse = self._client._pipeline.run(_request, stream=_stream, **kwargs)        response = pipeline_response.http_response
        if response.status_code == 200:
            response = pipeline_response.http_response
        if response.status_code == 200:
            response = response.http_response
        if response.status_code == 200:",90.35
"def build_configuration_policy_groups_create_or_update_request(resource_group_name: str, vpn_server_configuration_name: str, configuration_policy_group_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:    _headers = case_insensitive_dict(kwargs.pop('headers', {}) or {})    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})    api_version: str = kwargs.pop('api_version', _params.pop('api-version', '2024-03-01'))    content_type: Optional[str] = kwargs.pop('content_type', _headers.pop('Content-Type', None))    accept = _headers.pop('Accept', 'application/json')    _url = kwargs.pop('template_url', '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/vpnServerConfigurations/{vpnServerConfigurationName}/configurationPolicyGroups/{configurationPolicyGroupName}')    path_format_arguments = {'subscriptionId': _SERIALIZER.url('subscription_id', subscription_id, 'str'), 'resourceGroupName': _SERIALIZER.url('resource_group_name', resource_group_name, 'str'), 'vpnServerConfigurationName': _SERIALIZER.url('vpn_server_configuration_name', vpn_server_configuration_name, 'str'), 'configurationPolicyGroupName': _SERIALIZER.url('configuration_policy_group_name', configuration_policy_group_name, 'str')}    _url: str = _url.format(**path_format_arguments)    _params['api-version'] = _SERIALIZER.query('api_version', api_version, 'str')    <extra_id_0>        _headers['Content-Type'] = _SERIALIZER.header('content_type', content_type, 'str')    _headers['Accept'] = _SERIALIZER.header('accept', accept, 'str')    return HttpRequest(method='PUT', url=_url, params=_params, headers=_headers, **kwargs)",False,if content_type is not None:,"def build_configuration_policy_groups_create_or_update_request(resource_group_name: str, vpn_server_configuration_name: str, configuration_policy_group_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:    _headers = case_insensitive_dict(kwargs.pop('headers', {}) or {})    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})    content_type: Optional[str] = kwargs.pop('content_type',",99.70
"def __init__(self, *args, **kwargs):    input_args = list(args)    self._client = input_args.pop(0) if input_args else kwargs.pop('client')    self._config = input_args.pop(0) if input_args else kwargs.pop('config')    self._serialize = input_args.pop(0) if input_args else kwargs.pop('serializer')    self._deserialize = input_args.pop(0) if input_args else kwargs.pop('deserializer')    self._api_version = input_args.pop(0) if input_args else kwargs.pop('api_version')",False,,"def __init__ (self, *args, **kwargs):    input_args = list(args)    self._client = input_args.pop(0) if input_args else kwargs.pop('client')    self._config = input_args.pop(0) if input_args else kwargs.pop('config')    self._serialize = input_args.pop(0) if input_args else kwargs.pop('serializer')    self._deserialize = input_args.pop(0) if input_args else kwargs.pop('serializer')   ",99.47
"def _create_or_update_initial(self, resource_group_name: str, vpn_server_configuration_name: str, configuration_policy_group_name: str, vpn_server_configuration_policy_group_parameters: Union[_models.VpnServerConfigurationPolicyGroup, IO[bytes]], **kwargs: Any) -> Iterator[bytes]:    error_map: MutableMapping[int, Type[HttpResponseError]] = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError, 304: ResourceNotModifiedError}    error_map.update(kwargs.pop('error_map', {}) or {})    _headers = case_insensitive_dict(kwargs.pop('headers', {}) or {})    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})    api_version: str = kwargs.pop('api_version', _params.pop('api-version', self._api_version or '2024-03-01'))    content_type: Optional[str] = kwargs.pop('content_type', _headers.pop('Content-Type', None))    cls: ClsType[Iterator[bytes]] = kwargs.pop('cls', None)    content_type = content_type or 'application/json'    _json = None    _content = None    <extra_id_0>        return cls(pipeline_response, deserialized, {})    return deserialized",False,"if isinstance(vpn_server_configuration_policy_group_parameters, (IOBase, bytes)):        _content = vpn_server_configuration_policy_group_parameters    else:        _json = self._serialize.body(vpn_server_configuration_policy_group_parameters, 'VpnServerConfigurationPolicyGroup')    _request = build_configuration_policy_groups_create_or_update_request(resource_group_name=resource_group_name, vpn_server_configuration_name=vpn_server_configuration_name, configuration_policy_group_name=configuration_policy_group_name, subscription_id=self._config.subscription_id, api_version=api_version, content_type=content_type, json=_json, content=_content, headers=_headers, params=_params)    _request.url = self._client.format_url(_request.url)    _decompress = kwargs.pop('decompress', True)    _stream = True    pipeline_response: PipelineResponse = self._client._pipeline.run(_request, stream=_stream, **kwargs)    response = pipeline_response.http_response    if response.status_code not in [200, 201]:        try:            response.read()        except (StreamConsumedError, StreamClosedError):            pass        map_error(status_code=response.status_code, response=response, error_map=error_map)        raise HttpResponseError(response=response, error_format=ARMErrorFormat)    deserialized = response.stream_download(self._client._pipeline, decompress=_decompress)    if cls:","def _create_or_update_initial(self, resource_group_name: str, vpn_server_configuration_name: str, configuration_policy_group_name: str, configuration_policy_group_parameters: Union[_models.VpnServerConfigurationPolicyGroup, IO[bytes]], **kwargs: Any) -> Iterator[bytes]:    error_map: MutableMapping[int, Type[HttpResponseError]] = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError, 304: ResourceNotModifiedError}    error_map",99.51
"def _delete_initial(self, resource_group_name: str, vpn_server_configuration_name: str, configuration_policy_group_name: str, **kwargs: Any) -> Iterator[bytes]:    error_map: MutableMapping[int, Type[HttpResponseError]] = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError, 304: ResourceNotModifiedError}    error_map.update(kwargs.pop('error_map', {}) or {})    _headers = kwargs.pop('headers', {}) or {}    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})    api_version: str = kwargs.pop('api_version', _params.pop('api-version', self._api_version or '2024-03-01'))    cls: ClsType[Iterator[bytes]] = kwargs.pop('cls', None)    _request = build_configuration_policy_groups_delete_request(resource_group_name=resource_group_name, vpn_server_configuration_name=vpn_server_configuration_name, configuration_policy_group_name=configuration_policy_group_name, subscription_id=self._config.subscription_id, api_version=api_version, headers=_headers, params=_params)    _request.url = self._client.format_url(_request.url)    _decompress = kwargs.pop('decompress', True)    _stream = True    pipeline_response: PipelineResponse = self._client._pipeline.run(_request, stream=_stream, **kwargs)    response = pipeline_response.http_response    <extra_id_0>        return cls(pipeline_response, deserialized, {})    return deserialized@distributed_trace",False,"if response.status_code not in [200, 202, 204]:        try:            response.read()        except (StreamConsumedError, StreamClosedError):            pass        map_error(status_code=response.status_code, response=response, error_map=error_map)        raise HttpResponseError(response=response, error_format=ARMErrorFormat)    deserialized = response.stream_download(self._client._pipeline, decompress=_decompress)    if cls:","def _delete_initial(self, resource_group_name: str, vpn_server_configuration_name: str, configuration_policy_group_name: str, **kwargs: Any) -> Iterator[bytes]:    error_map: MutableMapping[int, Type[HttpResponseError]] = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError, 304: ResourceNotModifiedError}    error_map.update(kwargs.pop('error_map', {}) or {})    _headers = kwargs.pop('headers', {})",99.58
"def begin_create_or_update(self, resource_group_name: str, vpn_server_configuration_name: str, configuration_policy_group_name: str, vpn_server_configuration_policy_group_parameters: Union[_models.VpnServerConfigurationPolicyGroup, IO[bytes]], **kwargs: Any) -> LROPoller[_models.VpnServerConfigurationPolicyGroup]:        _headers = case_insensitive_dict(kwargs.pop('headers', {}) or {})    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})    api_version: str = kwargs.pop('api_version', _params.pop('api-version', self._api_version or '2024-03-01'))    content_type: Optional[str] = kwargs.pop('content_type', _headers.pop('Content-Type', None))    cls: ClsType[_models.VpnServerConfigurationPolicyGroup] = kwargs.pop('cls', None)    polling: Union[bool, PollingMethod] = kwargs.pop('polling', True)    lro_delay = kwargs.pop('polling_interval', self._config.polling_interval)    cont_token: Optional[str] = kwargs.pop('continuation_token', None)    <extra_id_0> x, headers=_headers, params=_params, **kwargs)        raw_result.http_response.read()    kwargs.pop('error_map', None)",False,"if cont_token is None:        raw_result = self._create_or_update_initial(resource_group_name=resource_group_name, vpn_server_configuration_name=vpn_server_configuration_name, configuration_policy_group_name=configuration_policy_group_name, vpn_server_configuration_policy_group_parameters=vpn_server_configuration_policy_group_parameters, api_version=api_version, content_type=content_type, cls=lambda x, y, z:","def begin_create_or_update(self, resource_group_name: str, vpn_server_configuration_name: str, configuration_policy_group_name: str, configuration_policy_group_parameters: Union[_models.VpnServerConfigurationPolicyGroup, IO[bytes]], **kwargs: Any) -> LROPoller[_models.VpnServerConfigurationPolicyGroup]:        _headers = case_insensitive_dict(kwargs.pop('headers', {}) or {})    _params = case_insensitive_dict(kwargs.pop('params",99.42
"def get_long_running_output(pipeline_response):        deserialized = self._deserialize('VpnServerConfigurationPolicyGroup', pipeline_response.http_response)        <extra_id_0>        return LROPoller[_models.VpnServerConfigurationPolicyGroup].from_continuation_token(polling_method=polling_method, continuation_token=cont_token, client=self._client, deserialization_callback=get_long_running_output)    return LROPoller[_models.VpnServerConfigurationPolicyGroup](self._client, raw_result, get_long_running_output, polling_method)@distributed_trace",False,"if cls:            return cls(pipeline_response, deserialized, {})        return deserialized    if polling is True:        polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, lro_options={'final-state-via': 'azure-async-operation'}, **kwargs))    elif polling is False:        polling_method = cast(PollingMethod, NoPolling())    else:        polling_method = polling    if cont_token:","def get_long_running_output(pipeline_response):        deserialized = self._deserialize('VpnServerConfigurationPolicyGroup', pipeline_response.http_response)
        if deserialized.has_key('pollingMethod') and deserialized.has_key('continuationToken') and deserialized.has_key('continuationToken') and deserialized.has_key('continuationToken') and deserialized.has_key('continuationToken') and deserialized.has_key('continuationToken') and not deserialized.has_key('continuationToken') and not deserialized.has",88.34
"def begin_delete(self, resource_group_name: str, vpn_server_configuration_name: str, configuration_policy_group_name: str, **kwargs: Any) -> LROPoller[None]:        _headers = kwargs.pop('headers', {}) or {}    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})    api_version: str = kwargs.pop('api_version', _params.pop('api-version', self._api_version or '2024-03-01'))    cls: ClsType[None] = kwargs.pop('cls', None)    polling: Union[bool, PollingMethod] = kwargs.pop('polling', True)    lro_delay = kwargs.pop('polling_interval', self._config.polling_interval)    cont_token: Optional[str] = kwargs.pop('continuation_token', None)    <extra_id_0> x, headers=_headers, params=_params, **kwargs)        raw_result.http_response.read()    kwargs.pop('error_map', None)",False,"if cont_token is None:        raw_result = self._delete_initial(resource_group_name=resource_group_name, vpn_server_configuration_name=vpn_server_configuration_name, configuration_policy_group_name=configuration_policy_group_name, api_version=api_version, cls=lambda x, y, z:","def begin_delete(self, resource_group_name: str, vpn_server_configuration_name: str, configuration_policy_group_name: str, **kwargs: Any) -> LROPoller[None]:        _headers = kwargs.pop('headers', {}) or {}    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})    api_version: str = kwargs.pop('api-version', _params.pop('api-version', self._api_version or '2024-03-",99.27
"def get_long_running_output(pipeline_response):        <extra_id_0>        return LROPoller[None].from_continuation_token(polling_method=polling_method, continuation_token=cont_token, client=self._client, deserialization_callback=get_long_running_output)    return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)@distributed_trace",False,"if cls:            return cls(pipeline_response, None, {})    if polling is True:        polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, lro_options={'final-state-via': 'location'}, **kwargs))    elif polling is False:        polling_method = cast(PollingMethod, NoPolling())    else:        polling_method = polling    if cont_token:","def get_long_running_output(pipeline_response):
        if pipeline_response.status_code == 200:
            return LROPoller[None].from_continuation_token(polling_method=polling_method, continuation_token=cont_token, client=self._client, deserialization_callback=get_long_running_output)    return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)@distributed_trace",95.11
"def get(self, resource_group_name: str, vpn_server_configuration_name: str, configuration_policy_group_name: str, **kwargs: Any) -> _models.VpnServerConfigurationPolicyGroup:        error_map: MutableMapping[int, Type[HttpResponseError]] = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError, 304: ResourceNotModifiedError}    error_map.update(kwargs.pop('error_map', {}) or {})    _headers = kwargs.pop('headers', {}) or {}    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})    api_version: str = kwargs.pop('api_version', _params.pop('api-version', self._api_version or '2024-03-01'))    cls: ClsType[_models.VpnServerConfigurationPolicyGroup] = kwargs.pop('cls', None)    _request = build_configuration_policy_groups_get_request(resource_group_name=resource_group_name, vpn_server_configuration_name=vpn_server_configuration_name, configuration_policy_group_name=configuration_policy_group_name, subscription_id=self._config.subscription_id, api_version=api_version, headers=_headers, params=_params)    _request.url = self._client.format_url(_request.url)    _stream = False    pipeline_response: PipelineResponse = self._client._pipeline.run(_request, stream=_stream, **kwargs)    response = pipeline_response.http_response    <extra_id_0>        return cls(pipeline_response, deserialized, {})    return deserialized@distributed_trace",False,"if response.status_code not in [200]:        map_error(status_code=response.status_code, response=response, error_map=error_map)        raise HttpResponseError(response=response, error_format=ARMErrorFormat)    deserialized = self._deserialize('VpnServerConfigurationPolicyGroup', pipeline_response.http_response)    if cls:","def get(self, resource_group_name: str, vpn_server_configuration_name: str, configuration_policy_group_name: str, **kwargs: Any) -> _models.VpnServerConfigurationPolicyGroup:        error_map: MutableMapping[int, Type[HttpResponseError]] = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError, 304: ResourceNotModifiedError}    error_map.update(kwargs.pop('error_map', {}) or {})    _headers = kwargs.pop('headers',",99.74
"def prepare_request(next_link=None):        <extra_id_0>            _request = HttpRequest('GET', next_link)            _request.url = self._client.format_url(_request.url)            _request.method = 'GET'        return _request",False,"if not next_link:            _request = build_configuration_policy_groups_list_by_vpn_server_configuration_request(resource_group_name=resource_group_name, vpn_server_configuration_name=vpn_server_configuration_name, subscription_id=self._config.subscription_id, api_version=api_version, headers=_headers, params=_params)            _request.url = self._client.format_url(_request.url)        else:","def prepare_request(self, next_link=None):if next_link is not None: _request = self._client.format_url(_request.url)            _request.method = 'GET'        return _request",92.65
"def extract_data(pipeline_response):        deserialized = self._deserialize('ListVpnServerConfigurationPolicyGroupsResult', pipeline_response)        list_of_elem = deserialized.value        <extra_id_0>            list_of_elem = cls(list_of_elem)        return (deserialized.next_link or None, iter(list_of_elem))",False,if cls:,"def extract_data(self, pipeline_response):        deserialized = self._deserialize('ListVpnServerConfigurationPolicyGroupsResult', pipeline_response)        list_of_elem = deserialized.value
        if isinstance(list_of_elem, list):
            list_of_elem = cls(list_of_elem)        return (deserialized.next_link or None, iter(list_of_elem))",96.32
"def get_next(next_link=None):        _request = prepare_request(next_link)        _stream = False        pipeline_response: PipelineResponse = self._client._pipeline.run(_request, stream=_stream, **kwargs)        response = pipeline_response.http_response        <extra_id_0>            map_error(status_code=response.status_code, response=response, error_map=error_map)            raise HttpResponseError(response=response, error_format=ARMErrorFormat)        return pipeline_response    return ItemPaged(get_next, extract_data)",False,if response.status_code not in [200]:,"def get_next(self, next_link=None):        _request = prepare_request(next_link)        _stream = False        pipeline_response: PipelineResponse = self._client._pipeline.run(_request, stream=_stream, **kwargs)        response = pipeline_response.http_response
        if response.status_code == 200:
            response = pipeline_response.http_response
        if response.status_code == 200:
            response = response.http_response
        if response.status_code == 200:",90.35
"def build_express_route_port_authorizations_create_or_update_request(resource_group_name: str, express_route_port_name: str, authorization_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:    _headers = case_insensitive_dict(kwargs.pop('headers', {}) or {})    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})    api_version: str = kwargs.pop('api_version', _params.pop('api-version', '2024-03-01'))    content_type: Optional[str] = kwargs.pop('content_type', _headers.pop('Content-Type', None))    accept = _headers.pop('Accept', 'application/json')    _url = kwargs.pop('template_url', '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRoutePorts/{expressRoutePortName}/authorizations/{authorizationName}')    path_format_arguments = {'resourceGroupName': _SERIALIZER.url('resource_group_name', resource_group_name, 'str'), 'expressRoutePortName': _SERIALIZER.url('express_route_port_name', express_route_port_name, 'str'), 'authorizationName': _SERIALIZER.url('authorization_name', authorization_name, 'str'), 'subscriptionId': _SERIALIZER.url('subscription_id', subscription_id, 'str')}    _url: str = _url.format(**path_format_arguments)    _params['api-version'] = _SERIALIZER.query('api_version', api_version, 'str')    <extra_id_0>        _headers['Content-Type'] = _SERIALIZER.header('content_type', content_type, 'str')    _headers['Accept'] = _SERIALIZER.header('accept', accept, 'str')    return HttpRequest(method='PUT', url=_url, params=_params, headers=_headers, **kwargs)",False,if content_type is not None:,"def build_express_route_port_authorizations_create_or_update_request(resource_group_name: str, express_route_port_name: str, authorization_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:    _headers = case_insensitive_dict(kwargs.pop('headers', {}) or {})    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})    api_version: str = kwargs.pop('api_version', _params.",99.46
"def __init__(self, *args, **kwargs):    input_args = list(args)    self._client = input_args.pop(0) if input_args else kwargs.pop('client')    self._config = input_args.pop(0) if input_args else kwargs.pop('config')    self._serialize = input_args.pop(0) if input_args else kwargs.pop('serializer')    self._deserialize = input_args.pop(0) if input_args else kwargs.pop('deserializer')    self._api_version = input_args.pop(0) if input_args else kwargs.pop('api_version')",False,,"def __init__ (self, *args, **kwargs):    input_args = list(args)    self._client = input_args.pop(0) if input_args else kwargs.pop('client')    self._config = input_args.pop(0) if input_args else kwargs.pop('config')    self._serialize = input_args.pop(0) if input_args else kwargs.pop('serializer')    self._deserialize = input_args.pop(0) if input_args else kwargs.pop('serializer')   ",99.47
"def _create_or_update_initial(self, resource_group_name: str, express_route_port_name: str, authorization_name: str, authorization_parameters: Union[_models.ExpressRoutePortAuthorization, IO[bytes]], **kwargs: Any) -> Iterator[bytes]:    error_map: MutableMapping[int, Type[HttpResponseError]] = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError, 304: ResourceNotModifiedError}    error_map.update(kwargs.pop('error_map', {}) or {})    _headers = case_insensitive_dict(kwargs.pop('headers', {}) or {})    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})    api_version: str = kwargs.pop('api_version', _params.pop('api-version', self._api_version or '2024-03-01'))    content_type: Optional[str] = kwargs.pop('content_type', _headers.pop('Content-Type', None))    cls: ClsType[Iterator[bytes]] = kwargs.pop('cls', None)    content_type = content_type or 'application/json'    _json = None    _content = None    <extra_id_0>        return cls(pipeline_response, deserialized, {})    return deserialized",False,"if isinstance(authorization_parameters, (IOBase, bytes)):        _content = authorization_parameters    else:        _json = self._serialize.body(authorization_parameters, 'ExpressRoutePortAuthorization')    _request = build_express_route_port_authorizations_create_or_update_request(resource_group_name=resource_group_name, express_route_port_name=express_route_port_name, authorization_name=authorization_name, subscription_id=self._config.subscription_id, api_version=api_version, content_type=content_type, json=_json, content=_content, headers=_headers, params=_params)    _request.url = self._client.format_url(_request.url)    _decompress = kwargs.pop('decompress', True)    _stream = True    pipeline_response: PipelineResponse = self._client._pipeline.run(_request, stream=_stream, **kwargs)    response = pipeline_response.http_response    if response.status_code not in [200, 201]:        try:            response.read()        except (StreamConsumedError, StreamClosedError):            pass        map_error(status_code=response.status_code, response=response, error_map=error_map)        raise HttpResponseError(response=response, error_format=ARMErrorFormat)    deserialized = response.stream_download(self._client._pipeline, decompress=_decompress)    if cls:","def _create_or_update_initial(self, resource_group_name: str, express_route_port_name: str, authorization_name: str, authorization_parameters: Union[_models.ExpressRoutePortAuthorization, IO[bytes]], **kwargs: Any) -> Iterator[bytes]:    error_map: MutableMapping[int, Type[HttpResponseError]] = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError, 304: ResourceNotModifiedError}    error_map.update(kwargs.pop('error",99.82
"def _delete_initial(self, resource_group_name: str, express_route_port_name: str, authorization_name: str, **kwargs: Any) -> Iterator[bytes]:    error_map: MutableMapping[int, Type[HttpResponseError]] = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError, 304: ResourceNotModifiedError}    error_map.update(kwargs.pop('error_map', {}) or {})    _headers = kwargs.pop('headers', {}) or {}    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})    api_version: str = kwargs.pop('api_version', _params.pop('api-version', self._api_version or '2024-03-01'))    cls: ClsType[Iterator[bytes]] = kwargs.pop('cls', None)    _request = build_express_route_port_authorizations_delete_request(resource_group_name=resource_group_name, express_route_port_name=express_route_port_name, authorization_name=authorization_name, subscription_id=self._config.subscription_id, api_version=api_version, headers=_headers, params=_params)    _request.url = self._client.format_url(_request.url)    _decompress = kwargs.pop('decompress', True)    _stream = True    pipeline_response: PipelineResponse = self._client._pipeline.run(_request, stream=_stream, **kwargs)    response = pipeline_response.http_response    <extra_id_0>        return cls(pipeline_response, deserialized, response_headers)    return deserialized@distributed_trace",False,"if response.status_code not in [200, 202, 204]:        try:            response.read()        except (StreamConsumedError, StreamClosedError):            pass        map_error(status_code=response.status_code, response=response, error_map=error_map)        raise HttpResponseError(response=response, error_format=ARMErrorFormat)    response_headers = {}    if response.status_code == 202:        response_headers['Location'] = self._deserialize('str', response.headers.get('Location'))        response_headers['Azure-AsyncOperation'] = self._deserialize('str', response.headers.get('Azure-AsyncOperation'))    deserialized = response.stream_download(self._client._pipeline, decompress=_decompress)    if cls:","def _delete_initial(self, resource_group_name: str, express_route_port_name: str, authorization_name: str, **kwargs: Any): -> Iterator[bytes]:    error_map: MutableMapping[int, Type[HttpResponseError]] = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError, 304: ResourceNotModifiedError}    error_map.update(kwargs.pop('error_map', {}) or {})    _headers = kwargs.pop('headers', {}) or {}    _",99.60
"def begin_create_or_update(self, resource_group_name: str, express_route_port_name: str, authorization_name: str, authorization_parameters: Union[_models.ExpressRoutePortAuthorization, IO[bytes]], **kwargs: Any) -> LROPoller[_models.ExpressRoutePortAuthorization]:        _headers = case_insensitive_dict(kwargs.pop('headers', {}) or {})    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})    api_version: str = kwargs.pop('api_version', _params.pop('api-version', self._api_version or '2024-03-01'))    content_type: Optional[str] = kwargs.pop('content_type', _headers.pop('Content-Type', None))    cls: ClsType[_models.ExpressRoutePortAuthorization] = kwargs.pop('cls', None)    polling: Union[bool, PollingMethod] = kwargs.pop('polling', True)    lro_delay = kwargs.pop('polling_interval', self._config.polling_interval)    cont_token: Optional[str] = kwargs.pop('continuation_token', None)    <extra_id_0> x, headers=_headers, params=_params, **kwargs)        raw_result.http_response.read()    kwargs.pop('error_map', None)",False,"if cont_token is None:        raw_result = self._create_or_update_initial(resource_group_name=resource_group_name, express_route_port_name=express_route_port_name, authorization_name=authorization_name, authorization_parameters=authorization_parameters, api_version=api_version, content_type=content_type, cls=lambda x, y, z:","def begin_create_or_update(self, resource_group_name: str, express_route_port_name: str, authorization_name: str, authorization_parameters: Union[_models.ExpressRoutePortAuthorization, IO[bytes]], **kwargs: Any) -> LROPoller[_models.ExpressRoutePortAuthorization]:        _headers = case_insensitive_dict(kwargs.pop('headers', {}) or {})    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})    api",99.88
"def get_long_running_output(pipeline_response):        deserialized = self._deserialize('ExpressRoutePortAuthorization', pipeline_response.http_response)        <extra_id_0>        return LROPoller[_models.ExpressRoutePortAuthorization].from_continuation_token(polling_method=polling_method, continuation_token=cont_token, client=self._client, deserialization_callback=get_long_running_output)    return LROPoller[_models.ExpressRoutePortAuthorization](self._client, raw_result, get_long_running_output, polling_method)@distributed_trace",False,"if cls:            return cls(pipeline_response, deserialized, {})        return deserialized    if polling is True:        polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, lro_options={'final-state-via': 'azure-async-operation'}, **kwargs))    elif polling is False:        polling_method = cast(PollingMethod, NoPolling())    else:        polling_method = polling    if cont_token:","def get_long_running_output(pipeline_response):        deserialized = self._deserialize('ExpressRoutePortAuthorization', pipeline_response.http_response)
        if deserialized.has_key('continuationToken') and deserialized.has_key('continuationToken') and deserialized.has_key('continuationToken') and deserialized.has_key('continuationToken') and deserialized.has_key('continuationToken') and deserialized.has_key('continuationToken') and not deserialized.has_key('continuationToken') and not deserialized.has",88.45
"def begin_delete(self, resource_group_name: str, express_route_port_name: str, authorization_name: str, **kwargs: Any) -> LROPoller[None]:        _headers = kwargs.pop('headers', {}) or {}    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})    api_version: str = kwargs.pop('api_version', _params.pop('api-version', self._api_version or '2024-03-01'))    cls: ClsType[None] = kwargs.pop('cls', None)    polling: Union[bool, PollingMethod] = kwargs.pop('polling', True)    lro_delay = kwargs.pop('polling_interval', self._config.polling_interval)    cont_token: Optional[str] = kwargs.pop('continuation_token', None)    <extra_id_0> x, headers=_headers, params=_params, **kwargs)        raw_result.http_response.read()    kwargs.pop('error_map', None)",False,"if cont_token is None:        raw_result = self._delete_initial(resource_group_name=resource_group_name, express_route_port_name=express_route_port_name, authorization_name=authorization_name, api_version=api_version, cls=lambda x, y, z:","def begin_delete(self, resource_group_name: str, express_route_port_name: str, authorization_name: str, **kwargs: Any) -> LROPoller[None]:        _headers = kwargs.pop('headers', {}) or {}    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})    api_version: str = kwargs.pop('api-version', _params.pop('api-version', self._api_version or '2024-03-01'))    cls",99.30
"def get_long_running_output(pipeline_response):        <extra_id_0>        return LROPoller[None].from_continuation_token(polling_method=polling_method, continuation_token=cont_token, client=self._client, deserialization_callback=get_long_running_output)    return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)@distributed_trace",False,"if cls:            return cls(pipeline_response, None, {})    if polling is True:        polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, lro_options={'final-state-via': 'azure-async-operation'}, **kwargs))    elif polling is False:        polling_method = cast(PollingMethod, NoPolling())    else:        polling_method = polling    if cont_token:","def get_long_running_output(pipeline_response):
        if pipeline_response.status_code == 200:
            return LROPoller[None].from_continuation_token(polling_method=polling_method, continuation_token=cont_token, client=self._client, deserialization_callback=get_long_running_output)    return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)@distributed_trace",95.11
"def get(self, resource_group_name: str, express_route_port_name: str, authorization_name: str, **kwargs: Any) -> _models.ExpressRoutePortAuthorization:        error_map: MutableMapping[int, Type[HttpResponseError]] = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError, 304: ResourceNotModifiedError}    error_map.update(kwargs.pop('error_map', {}) or {})    _headers = kwargs.pop('headers', {}) or {}    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})    api_version: str = kwargs.pop('api_version', _params.pop('api-version', self._api_version or '2024-03-01'))    cls: ClsType[_models.ExpressRoutePortAuthorization] = kwargs.pop('cls', None)    _request = build_express_route_port_authorizations_get_request(resource_group_name=resource_group_name, express_route_port_name=express_route_port_name, authorization_name=authorization_name, subscription_id=self._config.subscription_id, api_version=api_version, headers=_headers, params=_params)    _request.url = self._client.format_url(_request.url)    _stream = False    pipeline_response: PipelineResponse = self._client._pipeline.run(_request, stream=_stream, **kwargs)    response = pipeline_response.http_response    <extra_id_0>        return cls(pipeline_response, deserialized, {})    return deserialized@distributed_trace",False,"if response.status_code not in [200]:        map_error(status_code=response.status_code, response=response, error_map=error_map)        raise HttpResponseError(response=response, error_format=ARMErrorFormat)    deserialized = self._deserialize('ExpressRoutePortAuthorization', pipeline_response.http_response)    if cls:","def get(self, resource_group_name: str, express_route_port_name: str, authorization_name: str, **kwargs: Any) -> _models.ExpressRoutePortAuthorization:        error_map: MutableMapping[int, Type[HttpResponseError]] = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError, 304: ResourceNotModifiedError}    error_map.update(kwargs.pop('error_map', {}) or {})    _headers = kwargs.pop('headers', {}) or {}",99.55
"def prepare_request(next_link=None):        <extra_id_0>            _request = HttpRequest('GET', next_link)            _request.url = self._client.format_url(_request.url)            _request.method = 'GET'        return _request",False,"if not next_link:            _request = build_express_route_port_authorizations_list_request(resource_group_name=resource_group_name, express_route_port_name=express_route_port_name, subscription_id=self._config.subscription_id, api_version=api_version, headers=_headers, params=_params)            _request.url = self._client.format_url(_request.url)        else:","def prepare_request(self, next_link=None):if next_link is not None: _request = self._client.format_url(_request.url)            _request.method = 'GET'        return _request",92.65
"def extract_data(pipeline_response):        deserialized = self._deserialize('ExpressRoutePortAuthorizationListResult', pipeline_response)        list_of_elem = deserialized.value        <extra_id_0>            list_of_elem = cls(list_of_elem)        return (deserialized.next_link or None, iter(list_of_elem))",False,if cls:,"def extract_data(self, pipeline_response):        deserialized = self._deserialize('ExpressRoutePortAuthorizationListResult', pipeline_response)        list_of_elem = deserialized.value
        if isinstance(list_of_elem, list):
            list_of_elem = cls(list_of_elem)        return (deserialized.next_link or None, iter(list_of_elem))",96.03
"def get_next(next_link=None):        _request = prepare_request(next_link)        _stream = False        pipeline_response: PipelineResponse = self._client._pipeline.run(_request, stream=_stream, **kwargs)        response = pipeline_response.http_response        <extra_id_0>            map_error(status_code=response.status_code, response=response, error_map=error_map)            raise HttpResponseError(response=response, error_format=ARMErrorFormat)        return pipeline_response    return ItemPaged(get_next, extract_data)",False,if response.status_code not in [200]:,"def get_next(self, next_link=None):        _request = prepare_request(next_link)        _stream = False        pipeline_response: PipelineResponse = self._client._pipeline.run(_request, stream=_stream, **kwargs)        response = pipeline_response.http_response
        if response.status_code == 200:
            response = pipeline_response.http_response
        if response.status_code == 200:
            response = response.http_response
        if response.status_code == 200:",90.35
"def build_express_route_provider_ports_location_list_request(subscription_id: str, *, filter: Optional[str]=None, **kwargs: Any) -> HttpRequest:    _headers = case_insensitive_dict(kwargs.pop('headers', {}) or {})    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})    api_version: str = kwargs.pop('api_version', _params.pop('api-version', '2024-03-01'))    accept = _headers.pop('Accept', 'application/json')    _url = kwargs.pop('template_url', '/subscriptions/{subscriptionId}/providers/Microsoft.Network/expressRouteProviderPorts')    path_format_arguments = {'subscriptionId': _SERIALIZER.url('subscription_id', subscription_id, 'str')}    _url: str = _url.format(**path_format_arguments)    _params['api-version'] = _SERIALIZER.query('api_version', api_version, 'str')    <extra_id_0>        _params['$filter'] = _SERIALIZER.query('filter', filter, 'str')    _headers['Accept'] = _SERIALIZER.header('accept', accept, 'str')    return HttpRequest(method='GET', url=_url, params=_params, headers=_headers, **kwargs)",False,if filter is not None:,"def build_express_route_provider_ports_location_list_request(subscription_id: str, *, filter: Optional[str]=None, **kwargs: Any) -> HttpRequest:    _headers = case_insensitive_dict(kwargs.pop('headers', {}) or {})    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})    accept = _headers.pop('Accept', 'application/json')    _url = kwargs.pop('template_url', '/subscriptions/{subscriptionId}/providers/",99.60
"def __init__(self, *args, **kwargs):    input_args = list(args)    self._client = input_args.pop(0) if input_args else kwargs.pop('client')    self._config = input_args.pop(0) if input_args else kwargs.pop('config')    self._serialize = input_args.pop(0) if input_args else kwargs.pop('serializer')    self._deserialize = input_args.pop(0) if input_args else kwargs.pop('deserializer')    self._api_version = input_args.pop(0) if input_args else kwargs.pop('api_version')@distributed_trace",False,,"def __init__ (self, *args, **kwargs):    input_args = list(args)    self._client = input_args.pop(0) if input_args else kwargs.pop('client')    self._config = input_args.pop(0) if input_args else kwargs.pop('config')    self._serialize = input_args.pop(0) if input_args else kwargs.pop('serializer')    self._deserialize = input_args.pop(0) if input_args else kwargs.pop('serializer')   ",99.53
"def list(self, *, filter: Optional[str]=None, **kwargs: Any) -> _models.ExpressRouteProviderPortListResult:        error_map: MutableMapping[int, Type[HttpResponseError]] = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError, 304: ResourceNotModifiedError}    error_map.update(kwargs.pop('error_map', {}) or {})    _headers = kwargs.pop('headers', {}) or {}    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})    api_version: str = kwargs.pop('api_version', _params.pop('api-version', self._api_version or '2024-03-01'))    cls: ClsType[_models.ExpressRouteProviderPortListResult] = kwargs.pop('cls', None)    _request = build_express_route_provider_ports_location_list_request(subscription_id=self._config.subscription_id, filter=filter, api_version=api_version, headers=_headers, params=_params)    _request.url = self._client.format_url(_request.url)    _stream = False    pipeline_response: PipelineResponse = self._client._pipeline.run(_request, stream=_stream, **kwargs)    response = pipeline_response.http_response    <extra_id_0>        return cls(pipeline_response, deserialized, {})    return deserialized",False,"if response.status_code not in [200]:        map_error(status_code=response.status_code, response=response, error_map=error_map)        raise HttpResponseError(response=response, error_format=ARMErrorFormat)    deserialized = self._deserialize('ExpressRouteProviderPortListResult', pipeline_response.http_response)    if cls:","def list(self, *filter: Optional[str]=None, **kwargs: Any) -> _models.ExpressRouteProviderPortListResult:        error_map: MutableMapping[int, Type[HttpResponseError]] = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError, 304: ResourceNotModifiedError}    error_map.update(kwargs.pop('error_map', {}) or {})    _headers = kwargs.pop('headers', {}) or {}    _params = case_insensitive_dict(kwargs.",98.97
"def build_firewall_policy_idps_signatures_filter_values_list_request(resource_group_name: str, firewall_policy_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:    _headers = case_insensitive_dict(kwargs.pop('headers', {}) or {})    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})    api_version: str = kwargs.pop('api_version', _params.pop('api-version', '2024-03-01'))    content_type: Optional[str] = kwargs.pop('content_type', _headers.pop('Content-Type', None))    accept = _headers.pop('Accept', 'application/json')    _url = kwargs.pop('template_url', '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/firewallPolicies/{firewallPolicyName}/listIdpsFilterOptions')    path_format_arguments = {'resourceGroupName': _SERIALIZER.url('resource_group_name', resource_group_name, 'str'), 'firewallPolicyName': _SERIALIZER.url('firewall_policy_name', firewall_policy_name, 'str'), 'subscriptionId': _SERIALIZER.url('subscription_id', subscription_id, 'str')}    _url: str = _url.format(**path_format_arguments)    _params['api-version'] = _SERIALIZER.query('api_version', api_version, 'str')    <extra_id_0>        _headers['Content-Type'] = _SERIALIZER.header('content_type', content_type, 'str')    _headers['Accept'] = _SERIALIZER.header('accept', accept, 'str')    return HttpRequest(method='POST', url=_url, params=_params, headers=_headers, **kwargs)",False,if content_type is not None:,"def build_firewall_policy_idps_signatures_filter_values_list_request(resource_group_name: str, firewall_policy_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:    _headers = case_insensitive_dict(kwargs.pop('headers', {}) or {})    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})    api_version: str = kwargs.pop('api_version', _params.pop('api-version', '2024",99.77
"def __init__(self, *args, **kwargs):    input_args = list(args)    self._client = input_args.pop(0) if input_args else kwargs.pop('client')    self._config = input_args.pop(0) if input_args else kwargs.pop('config')    self._serialize = input_args.pop(0) if input_args else kwargs.pop('serializer')    self._deserialize = input_args.pop(0) if input_args else kwargs.pop('deserializer')    self._api_version = input_args.pop(0) if input_args else kwargs.pop('api_version')@distributed_trace",False,,"def __init__ (self, *args, **kwargs):    input_args = list(args)    self._client = input_args.pop(0) if input_args else kwargs.pop('client')    self._config = input_args.pop(0) if input_args else kwargs.pop('config')    self._serialize = input_args.pop(0) if input_args else kwargs.pop('serializer')    self._deserialize = input_args.pop(0) if input_args else kwargs.pop('serializer')   ",99.53
"def list(self, resource_group_name: str, firewall_policy_name: str, parameters: Union[_models.SignatureOverridesFilterValuesQuery, IO[bytes]], **kwargs: Any) -> _models.SignatureOverridesFilterValuesResponse:        error_map: MutableMapping[int, Type[HttpResponseError]] = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError, 304: ResourceNotModifiedError}    error_map.update(kwargs.pop('error_map', {}) or {})    _headers = case_insensitive_dict(kwargs.pop('headers', {}) or {})    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})    api_version: str = kwargs.pop('api_version', _params.pop('api-version', self._api_version or '2024-03-01'))    content_type: Optional[str] = kwargs.pop('content_type', _headers.pop('Content-Type', None))    cls: ClsType[_models.SignatureOverridesFilterValuesResponse] = kwargs.pop('cls', None)    content_type = content_type or 'application/json'    _json = None    _content = None    <extra_id_0>        return cls(pipeline_response, deserialized, {})    return deserialized",False,"if isinstance(parameters, (IOBase, bytes)):        _content = parameters    else:        _json = self._serialize.body(parameters, 'SignatureOverridesFilterValuesQuery')    _request = build_firewall_policy_idps_signatures_filter_values_list_request(resource_group_name=resource_group_name, firewall_policy_name=firewall_policy_name, subscription_id=self._config.subscription_id, api_version=api_version, content_type=content_type, json=_json, content=_content, headers=_headers, params=_params)    _request.url = self._client.format_url(_request.url)    _stream = False    pipeline_response: PipelineResponse = self._client._pipeline.run(_request, stream=_stream, **kwargs)    response = pipeline_response.http_response    if response.status_code not in [200]:        map_error(status_code=response.status_code, response=response, error_map=error_map)        raise HttpResponseError(response=response, error_format=ARMErrorFormat)    deserialized = self._deserialize('SignatureOverridesFilterValuesResponse', pipeline_response.http_response)    if cls:","def list(self, resource_group_name: str, firewall_policy_name: str, parameters: Union[_models.SignatureOverridesFilterValuesQuery, IO[bytes]], **kwargs: Any) -> _models.SignatureOverridesFilterValuesResponse:        error_map: MutableMapping[int, Type[HttpResponseError]] = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError, 304: ResourceNotModifiedError}    error_map.update(kwargs.pop('error_map', {}) or {})    _headers =",99.76
"def build_firewall_policy_idps_signatures_list_request(resource_group_name: str, firewall_policy_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:    _headers = case_insensitive_dict(kwargs.pop('headers', {}) or {})    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})    api_version: str = kwargs.pop('api_version', _params.pop('api-version', '2024-03-01'))    content_type: Optional[str] = kwargs.pop('content_type', _headers.pop('Content-Type', None))    accept = _headers.pop('Accept', 'application/json')    _url = kwargs.pop('template_url', '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/firewallPolicies/{firewallPolicyName}/listIdpsSignatures')    path_format_arguments = {'resourceGroupName': _SERIALIZER.url('resource_group_name', resource_group_name, 'str'), 'firewallPolicyName': _SERIALIZER.url('firewall_policy_name', firewall_policy_name, 'str'), 'subscriptionId': _SERIALIZER.url('subscription_id', subscription_id, 'str')}    _url: str = _url.format(**path_format_arguments)    _params['api-version'] = _SERIALIZER.query('api_version', api_version, 'str')    <extra_id_0>        _headers['Content-Type'] = _SERIALIZER.header('content_type', content_type, 'str')    _headers['Accept'] = _SERIALIZER.header('accept', accept, 'str')    return HttpRequest(method='POST', url=_url, params=_params, headers=_headers, **kwargs)",False,if content_type is not None:,"def build_firewall_policy_idps_signatures_list_request(resource_group_name: str, firewall_policy_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:    _headers = case_insensitive_dict(kwargs.pop('headers', {}) or {})    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})    api_version: str = kwargs.pop('api_version', _params.pop('api-version', '2024-03-01",99.65
"def __init__(self, *args, **kwargs):    input_args = list(args)    self._client = input_args.pop(0) if input_args else kwargs.pop('client')    self._config = input_args.pop(0) if input_args else kwargs.pop('config')    self._serialize = input_args.pop(0) if input_args else kwargs.pop('serializer')    self._deserialize = input_args.pop(0) if input_args else kwargs.pop('deserializer')    self._api_version = input_args.pop(0) if input_args else kwargs.pop('api_version')@distributed_trace",False,,"def __init__ (self, *args, **kwargs):    input_args = list(args)    self._client = input_args.pop(0) if input_args else kwargs.pop('client')    self._config = input_args.pop(0) if input_args else kwargs.pop('config')    self._serialize = input_args.pop(0) if input_args else kwargs.pop('serializer')    self._deserialize = input_args.pop(0) if input_args else kwargs.pop('serializer')   ",99.53
"def list(self, resource_group_name: str, firewall_policy_name: str, parameters: Union[_models.IDPSQueryObject, IO[bytes]], **kwargs: Any) -> _models.QueryResults:        error_map: MutableMapping[int, Type[HttpResponseError]] = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError, 304: ResourceNotModifiedError}    error_map.update(kwargs.pop('error_map', {}) or {})    _headers = case_insensitive_dict(kwargs.pop('headers', {}) or {})    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})    api_version: str = kwargs.pop('api_version', _params.pop('api-version', self._api_version or '2024-03-01'))    content_type: Optional[str] = kwargs.pop('content_type', _headers.pop('Content-Type', None))    cls: ClsType[_models.QueryResults] = kwargs.pop('cls', None)    content_type = content_type or 'application/json'    _json = None    _content = None    <extra_id_0>        return cls(pipeline_response, deserialized, {})    return deserialized",False,"if isinstance(parameters, (IOBase, bytes)):        _content = parameters    else:        _json = self._serialize.body(parameters, 'IDPSQueryObject')    _request = build_firewall_policy_idps_signatures_list_request(resource_group_name=resource_group_name, firewall_policy_name=firewall_policy_name, subscription_id=self._config.subscription_id, api_version=api_version, content_type=content_type, json=_json, content=_content, headers=_headers, params=_params)    _request.url = self._client.format_url(_request.url)    _stream = False    pipeline_response: PipelineResponse = self._client._pipeline.run(_request, stream=_stream, **kwargs)    response = pipeline_response.http_response    if response.status_code not in [200]:        map_error(status_code=response.status_code, response=response, error_map=error_map)        raise HttpResponseError(response=response, error_format=ARMErrorFormat)    deserialized = self._deserialize('QueryResults', pipeline_response.http_response)    if cls:","def list(self, resource_group_name: str, firewall_policy_name: str, parameters: Union[_models.IDPSQueryObject, IO[bytes]], **kwargs: Any) -> _models.QueryResults:        error_map: MutableMapping[int, Type[HttpResponseError]] = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError, 304: ResourceNotModifiedError}    error_map.update(kwargs.pop('error_map', {}) or {})    _headers = case_insensitive_",99.78
"def build_firewall_policy_idps_signatures_overrides_patch_request(resource_group_name: str, firewall_policy_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:    _headers = case_insensitive_dict(kwargs.pop('headers', {}) or {})    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})    api_version: str = kwargs.pop('api_version', _params.pop('api-version', '2024-03-01'))    content_type: Optional[str] = kwargs.pop('content_type', _headers.pop('Content-Type', None))    accept = _headers.pop('Accept', 'application/json')    _url = kwargs.pop('template_url', '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/firewallPolicies/{firewallPolicyName}/signatureOverrides/default')    path_format_arguments = {'resourceGroupName': _SERIALIZER.url('resource_group_name', resource_group_name, 'str'), 'firewallPolicyName': _SERIALIZER.url('firewall_policy_name', firewall_policy_name, 'str'), 'subscriptionId': _SERIALIZER.url('subscription_id', subscription_id, 'str')}    _url: str = _url.format(**path_format_arguments)    _params['api-version'] = _SERIALIZER.query('api_version', api_version, 'str')    <extra_id_0>        _headers['Content-Type'] = _SERIALIZER.header('content_type', content_type, 'str')    _headers['Accept'] = _SERIALIZER.header('accept', accept, 'str')    return HttpRequest(method='PATCH', url=_url, params=_params, headers=_headers, **kwargs)",False,if content_type is not None:,"def build_firewall_policy_idps_signatures_overrides_patch_request(resource_group_name: str, firewall_policy_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:    _headers = case_insensitive_dict(kwargs.pop('headers', {}) or {})    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})    api_version: str = kwargs.pop('api_version', _params.pop('api-version', '2024-03",99.71
"def build_firewall_policy_idps_signatures_overrides_put_request(resource_group_name: str, firewall_policy_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:    _headers = case_insensitive_dict(kwargs.pop('headers', {}) or {})    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})    api_version: str = kwargs.pop('api_version', _params.pop('api-version', '2024-03-01'))    content_type: Optional[str] = kwargs.pop('content_type', _headers.pop('Content-Type', None))    accept = _headers.pop('Accept', 'application/json')    _url = kwargs.pop('template_url', '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/firewallPolicies/{firewallPolicyName}/signatureOverrides/default')    path_format_arguments = {'resourceGroupName': _SERIALIZER.url('resource_group_name', resource_group_name, 'str'), 'firewallPolicyName': _SERIALIZER.url('firewall_policy_name', firewall_policy_name, 'str'), 'subscriptionId': _SERIALIZER.url('subscription_id', subscription_id, 'str')}    _url: str = _url.format(**path_format_arguments)    _params['api-version'] = _SERIALIZER.query('api_version', api_version, 'str')    <extra_id_0>        _headers['Content-Type'] = _SERIALIZER.header('content_type', content_type, 'str')    _headers['Accept'] = _SERIALIZER.header('accept', accept, 'str')    return HttpRequest(method='PUT', url=_url, params=_params, headers=_headers, **kwargs)",False,if content_type is not None:,"def build_firewall_policy_idps_signatures_overrides_put_request(resource_group_name: str, firewall_policy_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:    _headers = case_insensitive_dict(kwargs.pop('headers', {}) or {})    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})    api_version: str = kwargs.pop('api_version', _params.pop('api-version', '2024-03",99.71
"def __init__(self, *args, **kwargs):    input_args = list(args)    self._client = input_args.pop(0) if input_args else kwargs.pop('client')    self._config = input_args.pop(0) if input_args else kwargs.pop('config')    self._serialize = input_args.pop(0) if input_args else kwargs.pop('serializer')    self._deserialize = input_args.pop(0) if input_args else kwargs.pop('deserializer')    self._api_version = input_args.pop(0) if input_args else kwargs.pop('api_version')@distributed_trace",False,,"def __init__ (self, *args, **kwargs):    input_args = list(args)    self._client = input_args.pop(0) if input_args else kwargs.pop('client')    self._config = input_args.pop(0) if input_args else kwargs.pop('config')    self._serialize = input_args.pop(0) if input_args else kwargs.pop('serializer')    self._deserialize = input_args.pop(0) if input_args else kwargs.pop('serializer')   ",99.53
"def get(self, resource_group_name: str, firewall_policy_name: str, **kwargs: Any) -> _models.SignaturesOverrides:        error_map: MutableMapping[int, Type[HttpResponseError]] = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError, 304: ResourceNotModifiedError}    error_map.update(kwargs.pop('error_map', {}) or {})    _headers = kwargs.pop('headers', {}) or {}    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})    api_version: str = kwargs.pop('api_version', _params.pop('api-version', self._api_version or '2024-03-01'))    cls: ClsType[_models.SignaturesOverrides] = kwargs.pop('cls', None)    _request = build_firewall_policy_idps_signatures_overrides_get_request(resource_group_name=resource_group_name, firewall_policy_name=firewall_policy_name, subscription_id=self._config.subscription_id, api_version=api_version, headers=_headers, params=_params)    _request.url = self._client.format_url(_request.url)    _stream = False    pipeline_response: PipelineResponse = self._client._pipeline.run(_request, stream=_stream, **kwargs)    response = pipeline_response.http_response    <extra_id_0>        return cls(pipeline_response, deserialized, {})    return deserialized@distributed_trace",False,"if response.status_code not in [200]:        map_error(status_code=response.status_code, response=response, error_map=error_map)        raise HttpResponseError(response=response, error_format=ARMErrorFormat)    deserialized = self._deserialize('SignaturesOverrides', pipeline_response.http_response)    if cls:","def get(self, resource_group_name: str, firewall_policy_name: str, **kwargs: Any) -> _models.SignaturesOverrides:        error_map: MutableMapping[int, Type[HttpResponseError]] = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError, 304: ResourceNotModifiedError}    error_map.update(kwargs.pop('error_map', {}) or {})    _headers = kwargs.pop('headers', {}) or {}    _params = case_insensitive_dict(kwargs",99.53
"def list(self, resource_group_name: str, firewall_policy_name: str, **kwargs: Any) -> _models.SignaturesOverridesList:        error_map: MutableMapping[int, Type[HttpResponseError]] = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError, 304: ResourceNotModifiedError}    error_map.update(kwargs.pop('error_map', {}) or {})    _headers = kwargs.pop('headers', {}) or {}    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})    api_version: str = kwargs.pop('api_version', _params.pop('api-version', self._api_version or '2024-03-01'))    cls: ClsType[_models.SignaturesOverridesList] = kwargs.pop('cls', None)    _request = build_firewall_policy_idps_signatures_overrides_list_request(resource_group_name=resource_group_name, firewall_policy_name=firewall_policy_name, subscription_id=self._config.subscription_id, api_version=api_version, headers=_headers, params=_params)    _request.url = self._client.format_url(_request.url)    _stream = False    pipeline_response: PipelineResponse = self._client._pipeline.run(_request, stream=_stream, **kwargs)    response = pipeline_response.http_response    <extra_id_0>        return cls(pipeline_response, deserialized, {})    return deserialized@distributed_trace",False,"if response.status_code not in [200]:        map_error(status_code=response.status_code, response=response, error_map=error_map)        raise HttpResponseError(response=response, error_format=ARMErrorFormat)    deserialized = self._deserialize('SignaturesOverridesList', pipeline_response.http_response)    if cls:","def list(self, resource_group_name: str, firewall_policy_name: str, **kwargs: Any) -> _models.SignaturesOverridesList:        error_map: MutableMapping[int, Type[HttpResponseError]] = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError, 304: ResourceNotModifiedError}    error_map.update(kwargs.pop('error_map', {}) or {})    _headers = kwargs.pop('headers', {}) or {}    _params = case_insensitive_dict(",99.57
"def patch(self, resource_group_name: str, firewall_policy_name: str, parameters: Union[_models.SignaturesOverrides, IO[bytes]], **kwargs: Any) -> _models.SignaturesOverrides:        error_map: MutableMapping[int, Type[HttpResponseError]] = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError, 304: ResourceNotModifiedError}    error_map.update(kwargs.pop('error_map', {}) or {})    _headers = case_insensitive_dict(kwargs.pop('headers', {}) or {})    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})    api_version: str = kwargs.pop('api_version', _params.pop('api-version', self._api_version or '2024-03-01'))    content_type: Optional[str] = kwargs.pop('content_type', _headers.pop('Content-Type', None))    cls: ClsType[_models.SignaturesOverrides] = kwargs.pop('cls', None)    content_type = content_type or 'application/json'    _json = None    _content = None    <extra_id_0>        return cls(pipeline_response, deserialized, {})    return deserialized@distributed_trace",False,"if isinstance(parameters, (IOBase, bytes)):        _content = parameters    else:        _json = self._serialize.body(parameters, 'SignaturesOverrides')    _request = build_firewall_policy_idps_signatures_overrides_patch_request(resource_group_name=resource_group_name, firewall_policy_name=firewall_policy_name, subscription_id=self._config.subscription_id, api_version=api_version, content_type=content_type, json=_json, content=_content, headers=_headers, params=_params)    _request.url = self._client.format_url(_request.url)    _stream = False    pipeline_response: PipelineResponse = self._client._pipeline.run(_request, stream=_stream, **kwargs)    response = pipeline_response.http_response    if response.status_code not in [200]:        map_error(status_code=response.status_code, response=response, error_map=error_map)        raise HttpResponseError(response=response, error_format=ARMErrorFormat)    deserialized = self._deserialize('SignaturesOverrides', pipeline_response.http_response)    if cls:","def patch(self, resource_group_name: str, firewall_policy_name: str, parameters: Union[_models.SignaturesOverrides, IO[bytes]], **kwargs: Any) -> _models.SignaturesOverrides:        error_map: MutableMapping[int, Type[HttpResponseError]] = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError, 304: ResourceNotModifiedError}    error_map.update(kwargs.pop('error_map', {}) or {})    _headers = case_insensitive_dict(",99.80
"def put(self, resource_group_name: str, firewall_policy_name: str, parameters: Union[_models.SignaturesOverrides, IO[bytes]], **kwargs: Any) -> _models.SignaturesOverrides:        error_map: MutableMapping[int, Type[HttpResponseError]] = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError, 304: ResourceNotModifiedError}    error_map.update(kwargs.pop('error_map', {}) or {})    _headers = case_insensitive_dict(kwargs.pop('headers', {}) or {})    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})    api_version: str = kwargs.pop('api_version', _params.pop('api-version', self._api_version or '2024-03-01'))    content_type: Optional[str] = kwargs.pop('content_type', _headers.pop('Content-Type', None))    cls: ClsType[_models.SignaturesOverrides] = kwargs.pop('cls', None)    content_type = content_type or 'application/json'    _json = None    _content = None    <extra_id_0>        return cls(pipeline_response, deserialized, {})    return deserialized",False,"if isinstance(parameters, (IOBase, bytes)):        _content = parameters    else:        _json = self._serialize.body(parameters, 'SignaturesOverrides')    _request = build_firewall_policy_idps_signatures_overrides_put_request(resource_group_name=resource_group_name, firewall_policy_name=firewall_policy_name, subscription_id=self._config.subscription_id, api_version=api_version, content_type=content_type, json=_json, content=_content, headers=_headers, params=_params)    _request.url = self._client.format_url(_request.url)    _stream = False    pipeline_response: PipelineResponse = self._client._pipeline.run(_request, stream=_stream, **kwargs)    response = pipeline_response.http_response    if response.status_code not in [200]:        map_error(status_code=response.status_code, response=response, error_map=error_map)        raise HttpResponseError(response=response, error_format=ARMErrorFormat)    deserialized = self._deserialize('SignaturesOverrides', pipeline_response.http_response)    if cls:","def put(self, resource_group_name: str, firewall_policy_name: str, parameters: Union[_models.SignaturesOverrides, IO[bytes]], **kwargs: Any) -> _models.SignaturesOverrides:        error_map: MutableMapping[int, Type[HttpResponseError]] = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError, 304: ResourceNotModifiedError}    error_map.update(kwargs.pop('error_map', {}) or {})    _headers = case_insensitive_dict(",99.77
"def build_management_group_network_manager_connections_create_or_update_request(management_group_id: str, network_manager_connection_name: str, **kwargs: Any) -> HttpRequest:    _headers = case_insensitive_dict(kwargs.pop('headers', {}) or {})    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})    api_version: str = kwargs.pop('api_version', _params.pop('api-version', '2024-03-01'))    content_type: Optional[str] = kwargs.pop('content_type', _headers.pop('Content-Type', None))    accept = _headers.pop('Accept', 'application/json')    _url = kwargs.pop('template_url', '/providers/Microsoft.Management/managementGroups/{managementGroupId}/providers/Microsoft.Network/networkManagerConnections/{networkManagerConnectionName}')    path_format_arguments = {'managementGroupId': _SERIALIZER.url('management_group_id', management_group_id, 'str'), 'networkManagerConnectionName': _SERIALIZER.url('network_manager_connection_name', network_manager_connection_name, 'str')}    _url: str = _url.format(**path_format_arguments)    _params['api-version'] = _SERIALIZER.query('api_version', api_version, 'str')    <extra_id_0>        _headers['Content-Type'] = _SERIALIZER.header('content_type', content_type, 'str')    _headers['Accept'] = _SERIALIZER.header('accept', accept, 'str')    return HttpRequest(method='PUT', url=_url, params=_params, headers=_headers, **kwargs)",False,if content_type is not None:,"def build_management_group_network_manager_connections_create_or_update_request(management_group_id: str, network_manager_connection_name: str, **kwargs: Any) -> HttpRequest:    _headers = case_insensitive_dict(kwargs.pop('headers', {}) or {})    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})    api_version: str = kwargs.pop('api_version', _params.pop('api-version', '2024-03-",99.50
"def build_management_group_network_manager_connections_list_request(management_group_id: str, *, top: Optional[int]=None, skip_token: Optional[str]=None, **kwargs: Any) -> HttpRequest:    _headers = case_insensitive_dict(kwargs.pop('headers', {}) or {})    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})    api_version: str = kwargs.pop('api_version', _params.pop('api-version', '2024-03-01'))    accept = _headers.pop('Accept', 'application/json')    _url = kwargs.pop('template_url', '/providers/Microsoft.Management/managementGroups/{managementGroupId}/providers/Microsoft.Network/networkManagerConnections')    path_format_arguments = {'managementGroupId': _SERIALIZER.url('management_group_id', management_group_id, 'str')}    _url: str = _url.format(**path_format_arguments)    _params['api-version'] = _SERIALIZER.query('api_version', api_version, 'str')    <extra_id_0>        _params['$skipToken'] = _SERIALIZER.query('skip_token', skip_token, 'str')    _headers['Accept'] = _SERIALIZER.header('accept', accept, 'str')    return HttpRequest(method='GET', url=_url, params=_params, headers=_headers, **kwargs)",False,"if top is not None:        _params['$top'] = _SERIALIZER.query('top', top, 'int', maximum=20, minimum=1)    if skip_token is not None:","def build_management_group_network_manager_connections_list_request(management_group_id: str, *, top: Optional[int]=None, skip_token: Optional[str]=None, **kwargs: Any) -> HttpRequest:    _headers = case_insensitive_dict(kwargs.pop('headers', {}) or {})    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})    accept = _headers.pop('Accept', 'application/json')    _url = kwargs.pop",99.36
"def __init__(self, *args, **kwargs):    input_args = list(args)    self._client = input_args.pop(0) if input_args else kwargs.pop('client')    self._config = input_args.pop(0) if input_args else kwargs.pop('config')    self._serialize = input_args.pop(0) if input_args else kwargs.pop('serializer')    self._deserialize = input_args.pop(0) if input_args else kwargs.pop('deserializer')    self._api_version = input_args.pop(0) if input_args else kwargs.pop('api_version')@distributed_trace",False,,"def __init__ (self, *args, **kwargs):    input_args = list(args)    self._client = input_args.pop(0) if input_args else kwargs.pop('client')    self._config = input_args.pop(0) if input_args else kwargs.pop('config')    self._serialize = input_args.pop(0) if input_args else kwargs.pop('serializer')    self._deserialize = input_args.pop(0) if input_args else kwargs.pop('serializer')   ",99.53
"def create_or_update(self, management_group_id: str, network_manager_connection_name: str, parameters: Union[_models.NetworkManagerConnection, IO[bytes]], **kwargs: Any) -> _models.NetworkManagerConnection:        error_map: MutableMapping[int, Type[HttpResponseError]] = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError, 304: ResourceNotModifiedError}    error_map.update(kwargs.pop('error_map', {}) or {})    _headers = case_insensitive_dict(kwargs.pop('headers', {}) or {})    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})    api_version: str = kwargs.pop('api_version', _params.pop('api-version', self._api_version or '2024-03-01'))    content_type: Optional[str] = kwargs.pop('content_type', _headers.pop('Content-Type', None))    cls: ClsType[_models.NetworkManagerConnection] = kwargs.pop('cls', None)    content_type = content_type or 'application/json'    _json = None    _content = None    <extra_id_0>        return cls(pipeline_response, deserialized, {})    return deserialized@distributed_trace",False,"if isinstance(parameters, (IOBase, bytes)):        _content = parameters    else:        _json = self._serialize.body(parameters, 'NetworkManagerConnection')    _request = build_management_group_network_manager_connections_create_or_update_request(management_group_id=management_group_id, network_manager_connection_name=network_manager_connection_name, api_version=api_version, content_type=content_type, json=_json, content=_content, headers=_headers, params=_params)    _request.url = self._client.format_url(_request.url)    _stream = False    pipeline_response: PipelineResponse = self._client._pipeline.run(_request, stream=_stream, **kwargs)    response = pipeline_response.http_response    if response.status_code not in [200, 201]:        map_error(status_code=response.status_code, response=response, error_map=error_map)        raise HttpResponseError(response=response, error_format=ARMErrorFormat)    deserialized = self._deserialize('NetworkManagerConnection', pipeline_response.http_response)    if cls:","def create_or_update(self, management_group_id: str, network_manager_connection_name: str, parameters: Union[_models.NetworkManagerConnection, IO[bytes]], **kwargs: Any) -> _models.NetworkManagerConnection:        error_map: MutableMapping[int, Type[HttpResponseError]] = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError, 304: ResourceNotModifiedError}    error_map.update(kwargs.pop('error_map', {}) or {})    _",99.78
"def delete(self, management_group_id: str, network_manager_connection_name: str, **kwargs: Any) -> None:        error_map: MutableMapping[int, Type[HttpResponseError]] = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError, 304: ResourceNotModifiedError}    error_map.update(kwargs.pop('error_map', {}) or {})    _headers = kwargs.pop('headers', {}) or {}    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})    api_version: str = kwargs.pop('api_version', _params.pop('api-version', self._api_version or '2024-03-01'))    cls: ClsType[None] = kwargs.pop('cls', None)    _request = build_management_group_network_manager_connections_delete_request(management_group_id=management_group_id, network_manager_connection_name=network_manager_connection_name, api_version=api_version, headers=_headers, params=_params)    _request.url = self._client.format_url(_request.url)    _stream = False    pipeline_response: PipelineResponse = self._client._pipeline.run(_request, stream=_stream, **kwargs)    response = pipeline_response.http_response    <extra_id_0>        return cls(pipeline_response, None, {})@distributed_trace",False,"if response.status_code not in [200, 204]:        map_error(status_code=response.status_code, response=response, error_map=error_map)        raise HttpResponseError(response=response, error_format=ARMErrorFormat)    if cls:","def delete(self, management_group_id: str, network_manager_connection_name: str, **kwargs: Any) -> None:        error_map: MutableMapping[int, Type[HttpResponseError]] = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError, 304: ResourceNotModifiedError}    error_map.update(kwargs.pop('error_map', {}) or {})    _headers = kwargs.pop('headers', {}) or {}    _params = case_insensitive_dict(kwargs.pop",99.47
"def get(self, management_group_id: str, network_manager_connection_name: str, **kwargs: Any) -> _models.NetworkManagerConnection:        error_map: MutableMapping[int, Type[HttpResponseError]] = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError, 304: ResourceNotModifiedError}    error_map.update(kwargs.pop('error_map', {}) or {})    _headers = kwargs.pop('headers', {}) or {}    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})    api_version: str = kwargs.pop('api_version', _params.pop('api-version', self._api_version or '2024-03-01'))    cls: ClsType[_models.NetworkManagerConnection] = kwargs.pop('cls', None)    _request = build_management_group_network_manager_connections_get_request(management_group_id=management_group_id, network_manager_connection_name=network_manager_connection_name, api_version=api_version, headers=_headers, params=_params)    _request.url = self._client.format_url(_request.url)    _stream = False    pipeline_response: PipelineResponse = self._client._pipeline.run(_request, stream=_stream, **kwargs)    response = pipeline_response.http_response    <extra_id_0>        return cls(pipeline_response, deserialized, {})    return deserialized@distributed_trace",False,"if response.status_code not in [200]:        map_error(status_code=response.status_code, response=response, error_map=error_map)        raise HttpResponseError(response=response, error_format=ARMErrorFormat)    deserialized = self._deserialize('NetworkManagerConnection', pipeline_response.http_response)    if cls:","def get(self, management_group_id: str, network_manager_connection_name: str, **kwargs: Any) -> _models.NetworkManagerConnection:        error_map: MutableMapping[int, Type[HttpResponseError]] = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError, 304: ResourceNotModifiedError}    error_map.update(kwargs.pop('error_map', {}) or {})    _headers = kwargs.pop('headers', {}) or {}    _params = case_insensitive_",99.43
"def prepare_request(next_link=None):        <extra_id_0>            _request = HttpRequest('GET', next_link)            _request.url = self._client.format_url(_request.url)            _request.method = 'GET'        return _request",False,"if not next_link:            _request = build_management_group_network_manager_connections_list_request(management_group_id=management_group_id, top=top, skip_token=skip_token, api_version=api_version, headers=_headers, params=_params)            _request.url = self._client.format_url(_request.url)        else:","def prepare_request(self, next_link=None):if next_link is not None: _request = self._client.format_url(_request.url)            _request.method = 'GET'        return _request",92.65
"def extract_data(pipeline_response):        deserialized = self._deserialize('NetworkManagerConnectionListResult', pipeline_response)        list_of_elem = deserialized.value        <extra_id_0>            list_of_elem = cls(list_of_elem)        return (deserialized.next_link or None, iter(list_of_elem))",False,if cls:,"def extract_data(self, pipeline_response):        deserialized = self._deserialize('NetworkManagerConnectionListResult', pipeline_response)        list_of_elem = deserialized.value
        if isinstance(list_of_elem, list):
            list_of_elem = cls(list_of_elem)        return (deserialized.next_link or None, iter(list_of_elem))",96.17
"def get_next(next_link=None):        _request = prepare_request(next_link)        _stream = False        pipeline_response: PipelineResponse = self._client._pipeline.run(_request, stream=_stream, **kwargs)        response = pipeline_response.http_response        <extra_id_0>            map_error(status_code=response.status_code, response=response, error_map=error_map)            raise HttpResponseError(response=response, error_format=ARMErrorFormat)        return pipeline_response    return ItemPaged(get_next, extract_data)",False,if response.status_code not in [200]:,"def get_next(self, next_link=None):        _request = prepare_request(next_link)        _stream = False        pipeline_response: PipelineResponse = self._client._pipeline.run(_request, stream=_stream, **kwargs)        response = pipeline_response.http_response
        if response.status_code == 200:
            response = pipeline_response.http_response
        if response.status_code == 200:
            response = response.http_response
        if response.status_code == 200:",90.35
"def build_route_maps_create_or_update_request(resource_group_name: str, virtual_hub_name: str, route_map_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:    _headers = case_insensitive_dict(kwargs.pop('headers', {}) or {})    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})    api_version: str = kwargs.pop('api_version', _params.pop('api-version', '2024-03-01'))    content_type: Optional[str] = kwargs.pop('content_type', _headers.pop('Content-Type', None))    accept = _headers.pop('Accept', 'application/json')    _url = kwargs.pop('template_url', '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualHubs/{virtualHubName}/routeMaps/{routeMapName}')    path_format_arguments = {'subscriptionId': _SERIALIZER.url('subscription_id', subscription_id, 'str'), 'resourceGroupName': _SERIALIZER.url('resource_group_name', resource_group_name, 'str'), 'virtualHubName': _SERIALIZER.url('virtual_hub_name', virtual_hub_name, 'str'), 'routeMapName': _SERIALIZER.url('route_map_name', route_map_name, 'str')}    _url: str = _url.format(**path_format_arguments)    _params['api-version'] = _SERIALIZER.query('api_version', api_version, 'str')    <extra_id_0>        _headers['Content-Type'] = _SERIALIZER.header('content_type', content_type, 'str')    _headers['Accept'] = _SERIALIZER.header('accept', accept, 'str')    return HttpRequest(method='PUT', url=_url, params=_params, headers=_headers, **kwargs)",False,if content_type is not None:,"def build_route_maps_create_or_update_request(resource_group_name: str, virtual_hub_name: str, route_map_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:    _headers = case_insensitive_dict(kwargs.pop('headers', {}) or {})    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})    api_version: str = kwargs.pop('api_version', _params.pop('api-version',",99.68
"def __init__(self, *args, **kwargs):    input_args = list(args)    self._client = input_args.pop(0) if input_args else kwargs.pop('client')    self._config = input_args.pop(0) if input_args else kwargs.pop('config')    self._serialize = input_args.pop(0) if input_args else kwargs.pop('serializer')    self._deserialize = input_args.pop(0) if input_args else kwargs.pop('deserializer')    self._api_version = input_args.pop(0) if input_args else kwargs.pop('api_version')",False,,"def __init__ (self, *args, **kwargs):    input_args = list(args)    self._client = input_args.pop(0) if input_args else kwargs.pop('client')    self._config = input_args.pop(0) if input_args else kwargs.pop('config')    self._serialize = input_args.pop(0) if input_args else kwargs.pop('serializer')    self._deserialize = input_args.pop(0) if input_args else kwargs.pop('serializer')   ",99.47
"def _create_or_update_initial(self, resource_group_name: str, virtual_hub_name: str, route_map_name: str, route_map_parameters: Union[_models.RouteMap, IO[bytes]], **kwargs: Any) -> Iterator[bytes]:    error_map: MutableMapping[int, Type[HttpResponseError]] = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError, 304: ResourceNotModifiedError}    error_map.update(kwargs.pop('error_map', {}) or {})    _headers = case_insensitive_dict(kwargs.pop('headers', {}) or {})    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})    api_version: str = kwargs.pop('api_version', _params.pop('api-version', self._api_version or '2024-03-01'))    content_type: Optional[str] = kwargs.pop('content_type', _headers.pop('Content-Type', None))    cls: ClsType[Iterator[bytes]] = kwargs.pop('cls', None)    content_type = content_type or 'application/json'    _json = None    _content = None    <extra_id_0>        return cls(pipeline_response, deserialized, {})    return deserialized",False,"if isinstance(route_map_parameters, (IOBase, bytes)):        _content = route_map_parameters    else:        _json = self._serialize.body(route_map_parameters, 'RouteMap')    _request = build_route_maps_create_or_update_request(resource_group_name=resource_group_name, virtual_hub_name=virtual_hub_name, route_map_name=route_map_name, subscription_id=self._config.subscription_id, api_version=api_version, content_type=content_type, json=_json, content=_content, headers=_headers, params=_params)    _request.url = self._client.format_url(_request.url)    _decompress = kwargs.pop('decompress', True)    _stream = True    pipeline_response: PipelineResponse = self._client._pipeline.run(_request, stream=_stream, **kwargs)    response = pipeline_response.http_response    if response.status_code not in [200, 201]:        try:            response.read()        except (StreamConsumedError, StreamClosedError):            pass        map_error(status_code=response.status_code, response=response, error_map=error_map)        raise HttpResponseError(response=response, error_format=ARMErrorFormat)    deserialized = response.stream_download(self._client._pipeline, decompress=_decompress)    if cls:","def _create_or_update_initial(self, resource_group_name: str, virtual_hub_name: str, route_map_name: str, route_map_parameters: Union[_models.RouteMap, IO[bytes]], **kwargs: Any) -> Iterator[bytes]:    error_map: MutableMapping[int, Type[HttpResponseError]] = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError, 304: ResourceNotModifiedError}    error_map.update(kwargs.pop('error_",99.69
"def _delete_initial(self, resource_group_name: str, virtual_hub_name: str, route_map_name: str, **kwargs: Any) -> Iterator[bytes]:    error_map: MutableMapping[int, Type[HttpResponseError]] = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError, 304: ResourceNotModifiedError}    error_map.update(kwargs.pop('error_map', {}) or {})    _headers = kwargs.pop('headers', {}) or {}    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})    api_version: str = kwargs.pop('api_version', _params.pop('api-version', self._api_version or '2024-03-01'))    cls: ClsType[Iterator[bytes]] = kwargs.pop('cls', None)    _request = build_route_maps_delete_request(resource_group_name=resource_group_name, virtual_hub_name=virtual_hub_name, route_map_name=route_map_name, subscription_id=self._config.subscription_id, api_version=api_version, headers=_headers, params=_params)    _request.url = self._client.format_url(_request.url)    _decompress = kwargs.pop('decompress', True)    _stream = True    pipeline_response: PipelineResponse = self._client._pipeline.run(_request, stream=_stream, **kwargs)    response = pipeline_response.http_response    <extra_id_0>        return cls(pipeline_response, deserialized, {})    return deserialized@distributed_trace",False,"if response.status_code not in [200, 202, 204]:        try:            response.read()        except (StreamConsumedError, StreamClosedError):            pass        map_error(status_code=response.status_code, response=response, error_map=error_map)        raise HttpResponseError(response=response, error_format=ARMErrorFormat)    deserialized = response.stream_download(self._client._pipeline, decompress=_decompress)    if cls:","def _delete_initial(self, resource_group_name: str, virtual_hub_name: str, route_map_name: str, **kwargs: Any): -> Iterator[bytes]:    error_map: MutableMapping[int, Type[HttpResponseError]] = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError, 304: ResourceNotModifiedError}    error_map.update(kwargs.pop('error_map', {}) or {})    _headers = kwargs.pop('headers', {}) or {}    _",99.56
"def begin_create_or_update(self, resource_group_name: str, virtual_hub_name: str, route_map_name: str, route_map_parameters: Union[_models.RouteMap, IO[bytes]], **kwargs: Any) -> LROPoller[_models.RouteMap]:        _headers = case_insensitive_dict(kwargs.pop('headers', {}) or {})    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})    api_version: str = kwargs.pop('api_version', _params.pop('api-version', self._api_version or '2024-03-01'))    content_type: Optional[str] = kwargs.pop('content_type', _headers.pop('Content-Type', None))    cls: ClsType[_models.RouteMap] = kwargs.pop('cls', None)    polling: Union[bool, PollingMethod] = kwargs.pop('polling', True)    lro_delay = kwargs.pop('polling_interval', self._config.polling_interval)    cont_token: Optional[str] = kwargs.pop('continuation_token', None)    <extra_id_0> x, headers=_headers, params=_params, **kwargs)        raw_result.http_response.read()    kwargs.pop('error_map', None)",False,"if cont_token is None:        raw_result = self._create_or_update_initial(resource_group_name=resource_group_name, virtual_hub_name=virtual_hub_name, route_map_name=route_map_name, route_map_parameters=route_map_parameters, api_version=api_version, content_type=content_type, cls=lambda x, y, z:","def begin_create_or_update(self, resource_group_name: str, virtual_hub_name: str, route_map_name: str, route_map_parameters: Union[_models.RouteMap, IO[bytes]], **kwargs: Any) -> LROPoller[_models.RouteMap]:        _headers = case_insensitive_dict(kwargs.pop('headers', {}) or {})    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})    api_version: str",99.84
"def get_long_running_output(pipeline_response):        deserialized = self._deserialize('RouteMap', pipeline_response.http_response)        <extra_id_0>        return LROPoller[_models.RouteMap].from_continuation_token(polling_method=polling_method, continuation_token=cont_token, client=self._client, deserialization_callback=get_long_running_output)    return LROPoller[_models.RouteMap](self._client, raw_result, get_long_running_output, polling_method)@distributed_trace",False,"if cls:            return cls(pipeline_response, deserialized, {})        return deserialized    if polling is True:        polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, lro_options={'final-state-via': 'azure-async-operation'}, **kwargs))    elif polling is False:        polling_method = cast(PollingMethod, NoPolling())    else:        polling_method = polling    if cont_token:","def get_long_running_output(pipeline_response):        deserialized = self._deserialize('RouteMap', pipeline_response.http_response)
        if deserialized:        return LROPoller[_models.RouteMap].from_continuation_token(polling_method=polling_method, continuation_token=cont_token, client=self._client, deserialization_callback=get_long_running_output)    return LROPoller[_models.RouteMap].from_continuation_token(polling_method=polling",97.62
"def begin_delete(self, resource_group_name: str, virtual_hub_name: str, route_map_name: str, **kwargs: Any) -> LROPoller[None]:        _headers = kwargs.pop('headers', {}) or {}    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})    api_version: str = kwargs.pop('api_version', _params.pop('api-version', self._api_version or '2024-03-01'))    cls: ClsType[None] = kwargs.pop('cls', None)    polling: Union[bool, PollingMethod] = kwargs.pop('polling', True)    lro_delay = kwargs.pop('polling_interval', self._config.polling_interval)    cont_token: Optional[str] = kwargs.pop('continuation_token', None)    <extra_id_0> x, headers=_headers, params=_params, **kwargs)        raw_result.http_response.read()    kwargs.pop('error_map', None)",False,"if cont_token is None:        raw_result = self._delete_initial(resource_group_name=resource_group_name, virtual_hub_name=virtual_hub_name, route_map_name=route_map_name, api_version=api_version, cls=lambda x, y, z:","def begin_delete(self, resource_group_name: str, virtual_hub_name: str, route_map_name: str, **kwargs: Any) -> LROPoller[None]:        _headers = kwargs.pop('headers', {}) or {}    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})    api_version: str = kwargs.pop('api-version', _params.pop('api-version', self._api_version or '2024-03-01'))    cls",99.31
"def get_long_running_output(pipeline_response):        <extra_id_0>        return LROPoller[None].from_continuation_token(polling_method=polling_method, continuation_token=cont_token, client=self._client, deserialization_callback=get_long_running_output)    return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)@distributed_trace",False,"if cls:            return cls(pipeline_response, None, {})    if polling is True:        polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, lro_options={'final-state-via': 'location'}, **kwargs))    elif polling is False:        polling_method = cast(PollingMethod, NoPolling())    else:        polling_method = polling    if cont_token:","def get_long_running_output(pipeline_response):
        if pipeline_response.status_code == 200:
            return LROPoller[None].from_continuation_token(polling_method=polling_method, continuation_token=cont_token, client=self._client, deserialization_callback=get_long_running_output)    return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)@distributed_trace",95.11
"def get(self, resource_group_name: str, virtual_hub_name: str, route_map_name: str, **kwargs: Any) -> _models.RouteMap:        error_map: MutableMapping[int, Type[HttpResponseError]] = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError, 304: ResourceNotModifiedError}    error_map.update(kwargs.pop('error_map', {}) or {})    _headers = kwargs.pop('headers', {}) or {}    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})    api_version: str = kwargs.pop('api_version', _params.pop('api-version', self._api_version or '2024-03-01'))    cls: ClsType[_models.RouteMap] = kwargs.pop('cls', None)    _request = build_route_maps_get_request(resource_group_name=resource_group_name, virtual_hub_name=virtual_hub_name, route_map_name=route_map_name, subscription_id=self._config.subscription_id, api_version=api_version, headers=_headers, params=_params)    _request.url = self._client.format_url(_request.url)    _stream = False    pipeline_response: PipelineResponse = self._client._pipeline.run(_request, stream=_stream, **kwargs)    response = pipeline_response.http_response    <extra_id_0>        return cls(pipeline_response, deserialized, {})    return deserialized@distributed_trace",False,"if response.status_code not in [200]:        map_error(status_code=response.status_code, response=response, error_map=error_map)        raise HttpResponseError(response=response, error_format=ARMErrorFormat)    deserialized = self._deserialize('RouteMap', pipeline_response.http_response)    if cls:","def get(self, resource_group_name: str, virtual_hub_name: str, route_map_name: str, **kwargs: Any) -> _models.RouteMap:        error_map: MutableMapping[int, Type[HttpResponseError]] = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError, 304: ResourceNotModifiedError}    error_map.update(kwargs.pop('error_map', {}) or {})    _headers = kwargs.pop('headers', {}) or {}    _params",99.65
"def prepare_request(next_link=None):        <extra_id_0>            _request = HttpRequest('GET', next_link)            _request.url = self._client.format_url(_request.url)            _request.method = 'GET'        return _request",False,"if not next_link:            _request = build_route_maps_list_request(resource_group_name=resource_group_name, virtual_hub_name=virtual_hub_name, subscription_id=self._config.subscription_id, api_version=api_version, headers=_headers, params=_params)            _request.url = self._client.format_url(_request.url)        else:","def prepare_request(self, next_link=None):if next_link is not None: _request = self._client.format_url(_request.url)            _request.method = 'GET'        return _request",92.65
"def extract_data(pipeline_response):        deserialized = self._deserialize('ListRouteMapsResult', pipeline_response)        list_of_elem = deserialized.value        <extra_id_0>            list_of_elem = cls(list_of_elem)        return (deserialized.next_link or None, iter(list_of_elem))",False,if cls:,"def extract_data(self, pipeline_response):        deserialized = self._deserialize('ListRouteMapsResult', pipeline_response)        list_of_elem = deserialized.value
        if isinstance(list_of_elem, list):
            list_of_elem = cls(list_of_elem)        return (deserialized.next_link or None, iter(list_of_elem))",95.35
"def get_next(next_link=None):        _request = prepare_request(next_link)        _stream = False        pipeline_response: PipelineResponse = self._client._pipeline.run(_request, stream=_stream, **kwargs)        response = pipeline_response.http_response        <extra_id_0>            map_error(status_code=response.status_code, response=response, error_map=error_map)            raise HttpResponseError(response=response, error_format=ARMErrorFormat)        return pipeline_response    return ItemPaged(get_next, extract_data)",False,if response.status_code not in [200]:,"def get_next(self, next_link=None):        _request = prepare_request(next_link)        _stream = False        pipeline_response: PipelineResponse = self._client._pipeline.run(_request, stream=_stream, **kwargs)        response = pipeline_response.http_response
        if response.status_code == 200:
            response = pipeline_response.http_response
        if response.status_code == 200:
            response = response.http_response
        if response.status_code == 200:",90.35
"def build_routing_intent_create_or_update_request(resource_group_name: str, virtual_hub_name: str, routing_intent_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:    _headers = case_insensitive_dict(kwargs.pop('headers', {}) or {})    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})    api_version: str = kwargs.pop('api_version', _params.pop('api-version', '2024-03-01'))    content_type: Optional[str] = kwargs.pop('content_type', _headers.pop('Content-Type', None))    accept = _headers.pop('Accept', 'application/json')    _url = kwargs.pop('template_url', '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualHubs/{virtualHubName}/routingIntent/{routingIntentName}')    path_format_arguments = {'subscriptionId': _SERIALIZER.url('subscription_id', subscription_id, 'str'), 'resourceGroupName': _SERIALIZER.url('resource_group_name', resource_group_name, 'str'), 'virtualHubName': _SERIALIZER.url('virtual_hub_name', virtual_hub_name, 'str'), 'routingIntentName': _SERIALIZER.url('routing_intent_name', routing_intent_name, 'str')}    _url: str = _url.format(**path_format_arguments)    _params['api-version'] = _SERIALIZER.query('api_version', api_version, 'str')    <extra_id_0>        _headers['Content-Type'] = _SERIALIZER.header('content_type', content_type, 'str')    _headers['Accept'] = _SERIALIZER.header('accept', accept, 'str')    return HttpRequest(method='PUT', url=_url, params=_params, headers=_headers, **kwargs)",False,if content_type is not None:,"def build_routing_intent_create_or_update_request(resource_group_name: str, virtual_hub_name: str, routing_intent_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:    _headers = case_insensitive_dict(kwargs.pop('headers', {}) or {})    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})    api_version: str = kwargs.pop('api_version', _params.pop('api-",99.75
"def __init__(self, *args, **kwargs):    input_args = list(args)    self._client = input_args.pop(0) if input_args else kwargs.pop('client')    self._config = input_args.pop(0) if input_args else kwargs.pop('config')    self._serialize = input_args.pop(0) if input_args else kwargs.pop('serializer')    self._deserialize = input_args.pop(0) if input_args else kwargs.pop('deserializer')    self._api_version = input_args.pop(0) if input_args else kwargs.pop('api_version')",False,,"def __init__ (self, *args, **kwargs):    input_args = list(args)    self._client = input_args.pop(0) if input_args else kwargs.pop('client')    self._config = input_args.pop(0) if input_args else kwargs.pop('config')    self._serialize = input_args.pop(0) if input_args else kwargs.pop('serializer')    self._deserialize = input_args.pop(0) if input_args else kwargs.pop('serializer')   ",99.47
"def _create_or_update_initial(self, resource_group_name: str, virtual_hub_name: str, routing_intent_name: str, routing_intent_parameters: Union[_models.RoutingIntent, IO[bytes]], **kwargs: Any) -> Iterator[bytes]:    error_map: MutableMapping[int, Type[HttpResponseError]] = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError, 304: ResourceNotModifiedError}    error_map.update(kwargs.pop('error_map', {}) or {})    _headers = case_insensitive_dict(kwargs.pop('headers', {}) or {})    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})    api_version: str = kwargs.pop('api_version', _params.pop('api-version', self._api_version or '2024-03-01'))    content_type: Optional[str] = kwargs.pop('content_type', _headers.pop('Content-Type', None))    cls: ClsType[Iterator[bytes]] = kwargs.pop('cls', None)    content_type = content_type or 'application/json'    _json = None    _content = None    <extra_id_0>        return cls(pipeline_response, deserialized, {})    return deserialized",False,"if isinstance(routing_intent_parameters, (IOBase, bytes)):        _content = routing_intent_parameters    else:        _json = self._serialize.body(routing_intent_parameters, 'RoutingIntent')    _request = build_routing_intent_create_or_update_request(resource_group_name=resource_group_name, virtual_hub_name=virtual_hub_name, routing_intent_name=routing_intent_name, subscription_id=self._config.subscription_id, api_version=api_version, content_type=content_type, json=_json, content=_content, headers=_headers, params=_params)    _request.url = self._client.format_url(_request.url)    _decompress = kwargs.pop('decompress', True)    _stream = True    pipeline_response: PipelineResponse = self._client._pipeline.run(_request, stream=_stream, **kwargs)    response = pipeline_response.http_response    if response.status_code not in [200, 201]:        try:            response.read()        except (StreamConsumedError, StreamClosedError):            pass        map_error(status_code=response.status_code, response=response, error_map=error_map)        raise HttpResponseError(response=response, error_format=ARMErrorFormat)    deserialized = response.stream_download(self._client._pipeline, decompress=_decompress)    if cls:","def _create_or_update_initial(self, resource_group_name: str, virtual_hub_name: str, routing_intent_name: str, routing_intent_parameters: Union[_models.RoutingIntent, IO[bytes]], **kwargs: Any) -> Iterator[bytes]:    error_map: MutableMapping[int, Type[HttpResponseError]] = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError, 304: ResourceNotModifiedError}    error_map.update(kwargs.pop('",99.49
"def _delete_initial(self, resource_group_name: str, virtual_hub_name: str, routing_intent_name: str, **kwargs: Any) -> Iterator[bytes]:    error_map: MutableMapping[int, Type[HttpResponseError]] = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError, 304: ResourceNotModifiedError}    error_map.update(kwargs.pop('error_map', {}) or {})    _headers = kwargs.pop('headers', {}) or {}    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})    api_version: str = kwargs.pop('api_version', _params.pop('api-version', self._api_version or '2024-03-01'))    cls: ClsType[Iterator[bytes]] = kwargs.pop('cls', None)    _request = build_routing_intent_delete_request(resource_group_name=resource_group_name, virtual_hub_name=virtual_hub_name, routing_intent_name=routing_intent_name, subscription_id=self._config.subscription_id, api_version=api_version, headers=_headers, params=_params)    _request.url = self._client.format_url(_request.url)    _decompress = kwargs.pop('decompress', True)    _stream = True    pipeline_response: PipelineResponse = self._client._pipeline.run(_request, stream=_stream, **kwargs)    response = pipeline_response.http_response    <extra_id_0>        return cls(pipeline_response, deserialized, {})    return deserialized@distributed_trace",False,"if response.status_code not in [200, 202, 204]:        try:            response.read()        except (StreamConsumedError, StreamClosedError):            pass        map_error(status_code=response.status_code, response=response, error_map=error_map)        raise HttpResponseError(response=response, error_format=ARMErrorFormat)    deserialized = response.stream_download(self._client._pipeline, decompress=_decompress)    if cls:","def _delete_initial(self, resource_group_name: str, virtual_hub_name: str, routing_intent_name: str, **kwargs: Any): -> Iterator[bytes]:    error_map: MutableMapping[int, Type[HttpResponseError]] = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError, 304: ResourceNotModifiedError}    error_map.update(kwargs.pop('error_map', {}) or {})    _headers = kwargs.pop('headers', {}) or {}   ",99.53
"def begin_create_or_update(self, resource_group_name: str, virtual_hub_name: str, routing_intent_name: str, routing_intent_parameters: Union[_models.RoutingIntent, IO[bytes]], **kwargs: Any) -> LROPoller[_models.RoutingIntent]:        _headers = case_insensitive_dict(kwargs.pop('headers', {}) or {})    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})    api_version: str = kwargs.pop('api_version', _params.pop('api-version', self._api_version or '2024-03-01'))    content_type: Optional[str] = kwargs.pop('content_type', _headers.pop('Content-Type', None))    cls: ClsType[_models.RoutingIntent] = kwargs.pop('cls', None)    polling: Union[bool, PollingMethod] = kwargs.pop('polling', True)    lro_delay = kwargs.pop('polling_interval', self._config.polling_interval)    cont_token: Optional[str] = kwargs.pop('continuation_token', None)    <extra_id_0> x, headers=_headers, params=_params, **kwargs)        raw_result.http_response.read()    kwargs.pop('error_map', None)",False,"if cont_token is None:        raw_result = self._create_or_update_initial(resource_group_name=resource_group_name, virtual_hub_name=virtual_hub_name, routing_intent_name=routing_intent_name, routing_intent_parameters=routing_intent_parameters, api_version=api_version, content_type=content_type, cls=lambda x, y, z:","def begin_create_or_update(self, resource_group_name: str, virtual_hub_name: str, routing_intent_name: str, routing_intent_parameters: Union[_models.RoutingIntent, IO[bytes]], **kwargs: Any) -> LROPoller[_models.RoutingIntent]:        _headers = case_insensitive_dict(kwargs.pop('headers', {}) or {})    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})    api_version",99.63
"def get_long_running_output(pipeline_response):        deserialized = self._deserialize('RoutingIntent', pipeline_response.http_response)        <extra_id_0>        return LROPoller[_models.RoutingIntent].from_continuation_token(polling_method=polling_method, continuation_token=cont_token, client=self._client, deserialization_callback=get_long_running_output)    return LROPoller[_models.RoutingIntent](self._client, raw_result, get_long_running_output, polling_method)@distributed_trace",False,"if cls:            return cls(pipeline_response, deserialized, {})        return deserialized    if polling is True:        polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, lro_options={'final-state-via': 'azure-async-operation'}, **kwargs))    elif polling is False:        polling_method = cast(PollingMethod, NoPolling())    else:        polling_method = polling    if cont_token:","def get_long_running_output(pipeline_response):        deserialized = self._deserialize('RoutingIntent', pipeline_response.http_response)
        if deserialized.has_key('pollingMethod') and deserialized.has_key('continuationToken') and deserialized.has_key('continuationToken') and deserialized.has_key('continuationToken') and deserialized.has_key('continuationToken') and deserialized.has_key('continuationToken') and not deserialized.has_key('continuationToken') and not deserialized.has_key('",87.64
"def begin_delete(self, resource_group_name: str, virtual_hub_name: str, routing_intent_name: str, **kwargs: Any) -> LROPoller[None]:        _headers = kwargs.pop('headers', {}) or {}    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})    api_version: str = kwargs.pop('api_version', _params.pop('api-version', self._api_version or '2024-03-01'))    cls: ClsType[None] = kwargs.pop('cls', None)    polling: Union[bool, PollingMethod] = kwargs.pop('polling', True)    lro_delay = kwargs.pop('polling_interval', self._config.polling_interval)    cont_token: Optional[str] = kwargs.pop('continuation_token', None)    <extra_id_0> x, headers=_headers, params=_params, **kwargs)        raw_result.http_response.read()    kwargs.pop('error_map', None)",False,"if cont_token is None:        raw_result = self._delete_initial(resource_group_name=resource_group_name, virtual_hub_name=virtual_hub_name, routing_intent_name=routing_intent_name, api_version=api_version, cls=lambda x, y, z:","def begin_delete(self, resource_group_name: str, virtual_hub_name: str, routing_intent_name: str, **kwargs: Any) -> LROPoller[None]:        _headers = kwargs.pop('headers', {}) or {}    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})    api_version: str = kwargs.pop('api-version', _params.pop('api-version', self._api_version or '2024-03-01'))   ",99.39
"def get_long_running_output(pipeline_response):        <extra_id_0>        return LROPoller[None].from_continuation_token(polling_method=polling_method, continuation_token=cont_token, client=self._client, deserialization_callback=get_long_running_output)    return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)@distributed_trace",False,"if cls:            return cls(pipeline_response, None, {})    if polling is True:        polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, lro_options={'final-state-via': 'location'}, **kwargs))    elif polling is False:        polling_method = cast(PollingMethod, NoPolling())    else:        polling_method = polling    if cont_token:","def get_long_running_output(pipeline_response):
        if pipeline_response.status_code == 200:
            return LROPoller[None].from_continuation_token(polling_method=polling_method, continuation_token=cont_token, client=self._client, deserialization_callback=get_long_running_output)    return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)@distributed_trace",95.11
"def get(self, resource_group_name: str, virtual_hub_name: str, routing_intent_name: str, **kwargs: Any) -> _models.RoutingIntent:        error_map: MutableMapping[int, Type[HttpResponseError]] = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError, 304: ResourceNotModifiedError}    error_map.update(kwargs.pop('error_map', {}) or {})    _headers = kwargs.pop('headers', {}) or {}    _params = case_insensitive_dict(kwargs.pop('params', {}) or {})    api_version: str = kwargs.pop('api_version', _params.pop('api-version', self._api_version or '2024-03-01'))    cls: ClsType[_models.RoutingIntent] = kwargs.pop('cls', None)    _request = build_routing_intent_get_request(resource_group_name=resource_group_name, virtual_hub_name=virtual_hub_name, routing_intent_name=routing_intent_name, subscription_id=self._config.subscription_id, api_version=api_version, headers=_headers, params=_params)    _request.url = self._client.format_url(_request.url)    _stream = False    pipeline_response: PipelineResponse = self._client._pipeline.run(_request, stream=_stream, **kwargs)    response = pipeline_response.http_response    <extra_id_0>        return cls(pipeline_response, deserialized, {})    return deserialized@distributed_trace",False,"if response.status_code not in [200]:        map_error(status_code=response.status_code, response=response, error_map=error_map)        raise HttpResponseError(response=response, error_format=ARMErrorFormat)    deserialized = self._deserialize('RoutingIntent', pipeline_response.http_response)    if cls:","def get(self, resource_group_name: str, virtual_hub_name: str, routing_intent_name: str, **kwargs: Any) -> _models.RoutingIntent:        error_map: MutableMapping[int, Type[HttpResponseError]] = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError, 304: ResourceNotModifiedError}    error_map.update(kwargs.pop('error_map', {}) or {})    _headers = kwargs.pop('headers', {}) or {}    _",99.63
"def prepare_request(next_link=None):        <extra_id_0>            _request = HttpRequest('GET', next_link)            _request.url = self._client.format_url(_request.url)            _request.method = 'GET'        return _request",False,"if not next_link:            _request = build_routing_intent_list_request(resource_group_name=resource_group_name, virtual_hub_name=virtual_hub_name, subscription_id=self._config.subscription_id, api_version=api_version, headers=_headers, params=_params)            _request.url = self._client.format_url(_request.url)        else:","def prepare_request(self, next_link=None):if next_link is not None: _request = self._client.format_url(_request.url)            _request.method = 'GET'        return _request",92.65
"def extract_data(pipeline_response):        deserialized = self._deserialize('ListRoutingIntentResult', pipeline_response)        list_of_elem = deserialized.value        <extra_id_0>            list_of_elem = cls(list_of_elem)        return (deserialized.next_link or None, iter(list_of_elem))",False,if cls:,"def extract_data(self, pipeline_response):        deserialized = self._deserialize('ListRoutingIntentResult', pipeline_response)        list_of_elem = deserialized.value
        if isinstance(list_of_elem, listRoutingIntentResult):
            list_of_elem = cls(list_of_elem)        return (deserialized.next_link or None, iter(list_of_elem))",95.51
"def get_next(next_link=None):        _request = prepare_request(next_link)        _stream = False        pipeline_response: PipelineResponse = self._client._pipeline.run(_request, stream=_stream, **kwargs)        response = pipeline_response.http_response        <extra_id_0>            map_error(status_code=response.status_code, response=response, error_map=error_map)            raise HttpResponseError(response=response, error_format=ARMErrorFormat)        return pipeline_response    return ItemPaged(get_next, extract_data)",False,if response.status_code not in [200]:,"def get_next(self, next_link=None):        _request = prepare_request(next_link)        _stream = False        pipeline_response: PipelineResponse = self._client._pipeline.run(_request, stream=_stream, **kwargs)        response = pipeline_response.http_response
        if response.status_code == 200:
            response = pipeline_response.http_response
        if response.status_code == 200:
            response = response.http_response
        if response.status_code == 200:",90.35
